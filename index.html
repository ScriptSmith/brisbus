<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Brisbane Buses — Live Map (GTFS)</title>
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .ui { position: absolute; left: 12px; top: 12px; z-index: 2; background: rgba(255,255,255,0.95); padding: 12px; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.12); width: 320px; }
    .ui h1 { margin: 0 0 8px 0; font-size: 16px; }
    .controls { display: flex; gap: 8px; align-items: center; }
    .controls input[type=text] { flex: 1; padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd; }
    button { padding: 6px 8px; border-radius: 6px; border: 1px solid #ccc; background: #f6f6f6; cursor: pointer; }
    .meta { margin-top: 8px; font-size: 13px; color: #444; }
    .legend { margin-top: 8px; font-size: 13px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="ui">
    <h1>Brisbane buses — Live</h1>
    <div class="controls">
      <input id="routeFilter" placeholder="Filter by route number (optional)" />
      <button id="refreshBtn">Refresh</button>
    </div>
    <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
      <label><input id="autoRefresh" type="checkbox" checked /> Auto (10s)</label>
      <button id="locateBtn">My location</button>
    </div>
    <div class="meta">
      <div>Last update: <span id="lastUpdate">—</span></div>
      <div>Vehicles shown: <span id="count">0</span></div>
    </div>
    <div class="legend">Source: Translink GTFS &amp; GTFS-RT (proxied) — vector tiles: Carto basemap</div>
  </div>

  <script src="https://unpkg.com/protobufjs@7.2.3/dist/protobuf.min.js"></script>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const PROXY_FEED_URL = 'https://api.codetabs.com/v1/proxy?quest=https://gtfsrt.api.translink.com.au/api/realtime/SEQ/VehiclePositions';
    const PROXY_GTFS_URL = '/brisbus/SEQ_GTFS.zip';
    const PROTO_URL = 'https://raw.githubusercontent.com/google/transit/master/gtfs-realtime/proto/gtfs-realtime.proto';
    const REFRESH_INTERVAL_MS = 10000;
    const HISTORY_WINDOW_MS = 3 * 60 * 1000;
    const GTFS_CACHE_VERSION = 1; // Increment to invalidate cache

    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [153.0251, -27.4679],
      zoom: 11
    });
    map.addControl(new maplibregl.NavigationControl({showCompass: false}), 'top-right');

    let root = null, feedMessageType = null;
    let vehiclesGeoJSON = { type: 'FeatureCollection', features: [] };
    let pastPositions = { type: 'FeatureCollection', features: [] };
    let allShapes = {};      // shape_id → Feature
    let routeToShapes = {};  // route_id → Set(shape_id)
    let autoTimer = null;
    let userLocation = { type: 'FeatureCollection', features: [] };

    const lastUpdateEl = document.getElementById('lastUpdate');
    const countEl = document.getElementById('count');
    const refreshBtn = document.getElementById('refreshBtn');
    const autoRefreshEl = document.getElementById('autoRefresh');
    const routeFilterEl = document.getElementById('routeFilter');
    const locateBtn = document.getElementById('locateBtn');

    async function loadProto() {
      const res = await fetch(PROTO_URL);
      const protoText = await res.text();
      const parsed = protobuf.parse(protoText);
      root = parsed.root;
      feedMessageType = root.lookupType('transit_realtime.FeedMessage');
    }

    async function loadGTFS() {
      // Try loading zip from cache first
      const cacheKey = `gtfs_zip_v${GTFS_CACHE_VERSION}_${PROXY_GTFS_URL}`;
      let buf;
      
      try {
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
          console.log('Loading GTFS zip from cache');
          // Convert base64 back to ArrayBuffer
          const binaryString = atob(cached);
          buf = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            buf[i] = binaryString.charCodeAt(i);
          }
          buf = buf.buffer;
        }
      } catch (err) {
        console.warn('Failed to load from cache:', err);
      }

      if (!buf) {
        console.log('Fetching GTFS zip...');
        const res = await fetch(PROXY_GTFS_URL);
        buf = await res.arrayBuffer();
        
        // Cache the zip binary
        try {
          // Convert ArrayBuffer to base64 for localStorage
          const bytes = new Uint8Array(buf);
          let binary = '';
          for (let i = 0; i < bytes.length; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          localStorage.setItem(cacheKey, btoa(binary));
          console.log('GTFS zip cached successfully');
        } catch (err) {
          console.warn('Failed to save to cache:', err);
        }
      }

      const zip = await JSZip.loadAsync(buf);
      const shapesTxt = await zip.file("shapes.txt").async("string");
      const tripsTxt  = await zip.file("trips.txt").async("string");

      // --- Parse shapes.txt ---
      const lines = shapesTxt.trim().split(/\r?\n/);
      const headers = lines.shift().split(",");
      const idx = Object.fromEntries(headers.map((h,i)=>[h,i]));
      const tmp = {};
      for (const line of lines) {
        const parts = line.split(",");
        const sid = parts[idx["shape_id"]];
        const lat = parseFloat(parts[idx["shape_pt_lat"]]);
        const lon = parseFloat(parts[idx["shape_pt_lon"]]);
        const seq = parseInt(parts[idx["shape_pt_sequence"]],10);
        if (!tmp[sid]) tmp[sid] = [];
        tmp[sid].push({seq, coord:[lon,lat]});
      }
      for (const sid in tmp) {
        tmp[sid].sort((a,b)=>a.seq-b.seq);
        allShapes[sid] = {
          type:"Feature",
          geometry:{type:"LineString", coordinates:tmp[sid].map(p=>p.coord)},
          properties:{shape_id:sid}
        };
      }

      // --- Parse trips.txt (route_id -> shape_id) ---
      const tlines = tripsTxt.trim().split(/\r?\n/);
      const theaders = tlines.shift().split(",");
      const tidx = Object.fromEntries(theaders.map((h,i)=>[h,i]));
      for (const line of tlines) {
        const parts = line.split(",");
        const rid = parts[tidx["route_id"]];
        const sid = parts[tidx["shape_id"]];
        if (!rid || !sid) continue;
        if (!routeToShapes[rid]) routeToShapes[rid] = new Set();
        routeToShapes[rid].add(sid);
      }

      // Initialise empty layer
      map.addSource("routes",{type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"route-lines",
        type:"line",
        source:"routes",
        paint:{
          "line-color":"#0077cc",
          "line-width":2,
          "line-opacity":0.6
        }
      });

      // Initialise user location layer
      map.addSource("user-location", { type: "geojson", data: userLocation });
      map.addLayer({
        id:"user-location-circle",
        type:"circle",
        source:"user-location",
        paint:{
          "circle-radius":10,
          "circle-color":"#0066ff",
          "circle-stroke-width":2,
          "circle-stroke-color":"#fff"
        }
      });
    }

    async function fetchFeedAndUpdate() {
      try {
        const res = await fetch(PROXY_FEED_URL, {cache: 'no-store'});
        if (!res.ok) throw new Error('Network response not ok: ' + res.status);
        const buffer = await res.arrayBuffer();
        const uint8 = new Uint8Array(buffer);
        const message = feedMessageType.decode(uint8);
        const object = feedMessageType.toObject(message, { longs: String, enums: String, bytes: String });
        const geojson = feedToGeoJSON(object);
        updateHistory(geojson);
        vehiclesGeoJSON = geojson;
        updateMapSource();
        lastUpdateEl.textContent = new Date().toLocaleString();
        countEl.textContent = geojson.features.length;
      } catch (err) {
        console.error(err);
        lastUpdateEl.textContent = 'Error fetching feed';
      }
    }

    function feedToGeoJSON(feedObj) {
      const feats = [];
      if (!feedObj || !feedObj.entity) return { type: 'FeatureCollection', features: [] };
      for (const e of feedObj.entity) {
        if (!e.vehicle) continue;
        const vp = e.vehicle.position;
        if (!vp || vp.latitude == null || vp.longitude == null) continue;
        const props = {
          id: e.id || (e.vehicle.vehicle && e.vehicle.vehicle.id) || null,
          label: (e.vehicle.vehicle && `${e.vehicle.trip.routeId.split("-")[0]}: ${e.vehicle.vehicle.label}`) || null,
          route_id: e.vehicle.trip && e.vehicle.trip.routeId || null,
          trip_id: e.vehicle.trip && e.vehicle.trip.tripId || null,
          bearing: vp.bearing || null,
          speed: vp.speed || null,
          current_stop_sequence: e.vehicle.currentStopSequence || null,
          timestamp: e.vehicle.timestamp || null
        };
        feats.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [vp.longitude, vp.latitude] },
          properties: props
        });
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function updateHistory(currentGeoJSON) {
      const now = Date.now();
      for (const f of currentGeoJSON.features) {
        if (f.properties.timestamp) {
          const tsMs = Number(f.properties.timestamp) * 1000;
          pastPositions.features.push({
            type: 'Feature',
            geometry: f.geometry,
            properties: { ...f.properties, historyTs: tsMs }
          });
        }
      }
      pastPositions.features = pastPositions.features.filter(f => now - f.properties.historyTs <= HISTORY_WINDOW_MS);
    }

    function applyFilter(geojson) {
      const filterText = routeFilterEl.value.trim().toLowerCase();
      if (!filterText) return geojson;
      return {
        type: 'FeatureCollection',
        features: geojson.features.filter(f => {
          return (f.properties.route_id && f.properties.route_id.toLowerCase().includes(filterText)) ||
                 (f.properties.label && f.properties.label.toLowerCase().includes(filterText));
        })
      };
    }

    function updateMapSource() {
      const filteredVehicles = applyFilter(vehiclesGeoJSON);
      const filteredHistory = applyFilter(pastPositions);

      // --- Filter shapes based on filter text ---
      const filterText = routeFilterEl.value.trim().toLowerCase();
      let routeIds = new Set();
      if (filterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(filterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      const shapeFeatures = [];
      for (const rid of routeIds) {
        const sids = routeToShapes[rid];
        if (!sids) continue;
        for (const sid of sids) {
          if (allShapes[sid]) shapeFeatures.push(allShapes[sid]);
        }
      }

      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
        map.getSource('vehicle-history').setData(filteredHistory);
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
      } else {
        map.addSource('vehicles', { type: 'geojson', data: filteredVehicles });
        map.addLayer({
          id: 'vehicle-circles',
          type: 'circle',
          source: 'vehicles',
          paint: { 'circle-radius': 6, 'circle-stroke-width': 1, 'circle-stroke-color': '#fff' }
        });
        map.addLayer({
          id: 'vehicle-labels',
          type: 'symbol',
          source: 'vehicles',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ['get', 'route_id'], ''],
            'text-size': 12,
            'text-offset': [0, 1.3]
          }
        });
        map.on('click', 'vehicle-circles', (e) => {
          const props = e.features[0].properties;
          const html = `<div style="min-width:150px"><strong>${props.label || props.route_id || 'Vehicle'}</strong><br/>Trip: ${props.trip_id || '-'}<br/>ID: ${props.id || '-'}<br/>Last seen: ${props.timestamp ? new Date(Number(props.timestamp) * 1000).toLocaleTimeString() : '-'}</div>`;
          new maplibregl.Popup().setLngLat(e.lngLat).setHTML(html).addTo(map);
        });
        map.on('mouseenter', 'vehicle-circles', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vehicle-circles', () => map.getCanvas().style.cursor = '');

        map.addSource('vehicle-history', { type: 'geojson', data: filteredHistory });
        map.addLayer({
          id: 'vehicle-history-dots',
          type: 'circle',
          source: 'vehicle-history',
          paint: { 'circle-radius': 3, 'circle-color': '#888', 'circle-opacity': 0.6 }
        });
        map.getSource("routes").setData({type:"FeatureCollection",features:shapeFeatures});
      }
    }

    refreshBtn.addEventListener('click', () => fetchFeedAndUpdate());
    routeFilterEl.addEventListener('input', () => updateMapSource());
    autoRefreshEl.addEventListener('change', () => { if (autoRefreshEl.checked) startAutoRefresh(); else stopAutoRefresh(); });
    locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) return alert('Geolocation not available');
      navigator.geolocation.getCurrentPosition(pos => {
        const coords = [pos.coords.longitude, pos.coords.latitude];
        userLocation.features = [{
          type: 'Feature',
          geometry: { type: 'Point', coordinates: coords }
        }];
        map.getSource('user-location').setData(userLocation);
        map.flyTo({ center: coords, zoom: 14 });
      }, e => alert('Unable to get location: ' + e.message));
    });

    function startAutoRefresh() {
      stopAutoRefresh();
      autoTimer = setInterval(fetchFeedAndUpdate, REFRESH_INTERVAL_MS);
    }
    function stopAutoRefresh() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }

    (async function(){
      try {
        await loadProto();
        map.on('load', async () => {
          await loadGTFS();
          fetchFeedAndUpdate();
          startAutoRefresh();
        });
      } catch (err) {
        console.error('Startup error', err);
        alert('Failed to initialise: ' + err.message);
      }
    })();
  </script>
</body>
</html>
