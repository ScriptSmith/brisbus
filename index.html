<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="description" content="Live Brisbane bus tracking map using GTFS real-time data" />
  <meta name="theme-color" content="#0077cc" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Brisbane Buses" />
  <title>Brisbane Buses ‚Äî Live Map (GTFS)</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    
    .ui { 
      position: absolute; 
      left: 12px; 
      top: 12px; 
      right: 12px;
      z-index: 2; 
      background: rgba(255,255,255,0.97); 
      padding: 14px 16px; 
      border-radius: 12px; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
      max-width: 420px;
      backdrop-filter: blur(10px);
    }
    
    .ui h1 { 
      margin: 0 0 12px 0; 
      font-size: 18px; 
      font-weight: 600;
      color: #1a1a1a;
      letter-spacing: -0.01em;
    }
    
    .controls { 
      display: flex; 
      gap: 8px; 
      align-items: stretch; 
      flex-wrap: wrap; 
    }
    
    .controls-row {
      display: flex;
      gap: 8px;
      width: 100%;
    }
    
    .input-wrapper {
      position: relative;
      flex: 1;
      min-width: 120px;
    }
    
    .controls input[type=text] { 
      width: 100%;
      padding: 11px 36px 11px 12px; 
      border-radius: 8px; 
      border: 1.5px solid #ddd; 
      font-size: 15px;
      background: #fff;
      transition: border-color 0.2s, box-shadow 0.2s;
      box-sizing: border-box;
    }
    
    .controls input[type=text]:focus { 
      outline: none;
      border-color: #0077cc;
      box-shadow: 0 0 0 3px rgba(0, 119, 204, 0.1);
    }
    
    .clear-btn {
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 16px;
      color: #888;
      display: none;
      box-shadow: none;
      transition: color 0.2s;
      line-height: 1;
    }
    
    .clear-btn:hover {
      color: #333;
      background: transparent;
      border: none;
      box-shadow: none;
      transform: translateY(-50%);
    }
    
    .clear-btn:active {
      transform: translateY(-50%);
    }
    
    .clear-btn.visible {
      display: block;
    }
    
    button { 
      padding: 11px 14px; 
      border-radius: 8px; 
      border: 1.5px solid #d0d0d0; 
      background: linear-gradient(to bottom, #fff, #f8f8f8); 
      cursor: pointer; 
      font-size: 18px;
      font-weight: 500;
      color: #333;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.15s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      white-space: nowrap;
      line-height: 1;
    }
    
    button:hover { 
      background: linear-gradient(to bottom, #f8f8f8, #f0f0f0);
      border-color: #b8b8b8;
      box-shadow: 0 2px 4px rgba(0,0,0,0.12);
    }
    
    button:active { 
      background: #e8e8e8;
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }
    
    button:disabled,
    input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    
    .toggle-btn.active {
      background: linear-gradient(to bottom, #0077cc, #0066b3);
      border-color: #0055aa;
      color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    
    .toggle-btn.active:hover {
      background: linear-gradient(to bottom, #0066b3, #005599);
      border-color: #004488;
    }
    
    /* Follow mode indicator */
    .follow-indicator {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 119, 204, 0.95);
      color: white;
      padding: 10px 20px;
      padding-right: 40px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 10;
      display: none;
      animation: slideUp 0.3s ease-out;
    }
    
    .follow-indicator.visible {
      display: block;
    }
    
    .follow-indicator-close {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 18px;
      color: white;
      line-height: 1;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .follow-indicator-close:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    
    

    
    .meta { 
      margin-top: 12px; 
      padding-top: 12px;
      border-top: 1px solid #e8e8e8;
      font-size: 14px; 
      color: #555;
      line-height: 1.6;
    }
    
    .meta div {
      margin-bottom: 4px;
    }
    
    .meta span {
      font-weight: 500;
      color: #1a1a1a;
    }
    
    .legend { 
      margin-top: 10px; 
      padding-top: 10px;
      border-top: 1px solid #e8e8e8;
      font-size: 12px; 
      color: #777; 
      line-height: 1.5; 
    }
    
    /* Custom popup styling */
    .maplibregl-popup-content {
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      padding: 12px 14px;
    }
    
    .maplibregl-popup-close-button {
      font-size: 20px;
      padding: 4px 8px;
      color: #888;
    }
    
    .maplibregl-popup-close-button:hover {
      background: #f0f0f0;
      color: #333;
    }
    
    /* Mobile responsive styles */
    @media (max-width: 768px) {
      .ui {
        left: 10px;
        right: 10px;
        top: 10px;
        padding: 10px;
        max-width: none;
      }
      
      .ui h1 {
        font-size: 16px;
        margin-bottom: 8px;
      }
      
      .controls {
        gap: 6px;
      }
      
      .input-wrapper {
        min-width: 0;
      }
      
      .controls input[type=text] {
        padding: 10px 36px 10px 10px;
        font-size: 16px; /* Prevent zoom on iOS */
      }
      
      button {
        padding: 10px 12px;
        font-size: 14px;
        white-space: nowrap;
      }
      
      .meta {
        margin-top: 8px;
        padding-top: 8px;
        font-size: 13px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      
      .meta div {
        margin-bottom: 0;
        white-space: nowrap;
      }
      
      .legend {
        display: none; /* Hide on mobile */
      }
    }
    
    @media (max-width: 640px) {
      .ui {
        padding: 8px;
      }
      
      .ui h1 { 
        font-size: 15px; 
        margin-bottom: 6px;
      }
      
      .controls { 
        gap: 4px;
      }
      
      .controls input[type=text] { 
        padding: 9px 32px 9px 8px;
      }
      
      button { 
        padding: 9px 10px; 
        font-size: 13px;
      }
      
      .meta { 
        font-size: 12px; 
        margin-top: 6px;
        padding-top: 6px;
      }
    }
    
    @media (max-width: 400px) {
      .ui {
        left: 8px;
        right: 8px;
        top: 8px;
        padding: 6px;
      }
      
      .ui h1 {
        font-size: 14px;
        margin-bottom: 4px;
      }
      
      .controls { 
        gap: 3px;
      }
      
      .controls input[type=text] { 
        padding: 8px 28px 8px 6px;
        font-size: 16px;
      }
      
      button {
        padding: 8px 8px;
        font-size: 12px;
      }
      
      .meta {
        font-size: 11px;
        margin-top: 4px;
        padding-top: 4px;
      }
    }
    
    /* Status bar */
    #statusBar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 119, 204, 0.95);
      color: white;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      z-index: 1000;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.15);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    #statusBar.hidden {
      transform: translateY(100%);
      opacity: 0;
    }
    
    /* Debug toggle icon */
    #debugToggle {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.9);
      border: 1.5px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      z-index: 999;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: all 0.2s ease;
      user-select: none;
    }
    
    #debugToggle:hover {
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 3px 12px rgba(0,0,0,0.2);
      transform: scale(1.05);
    }
    
    #debugToggle.active {
      background: rgba(0, 119, 204, 0.95);
      color: white;
      border-color: #0055aa;
    }
    
    /* Debug pane */
    #debugPane {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40vh;
      background: rgba(30, 30, 30, 0.97);
      color: #e0e0e0;
      z-index: 998;
      display: flex;
      flex-direction: column;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    
    #debugPane.visible {
      transform: translateY(0);
    }
    
    #debugPane .debug-header {
      padding: 10px 16px;
      background: rgba(0, 119, 204, 0.9);
      color: white;
      font-weight: 600;
      font-size: 14px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #debugPane .debug-controls {
      display: flex;
      gap: 8px;
    }
    
    #debugPane .debug-controls button {
      padding: 4px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }
    
    #debugPane .debug-controls button:hover {
      background: rgba(255,255,255,0.3);
    }
    
    #debugPane .debug-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px 16px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
      font-size: 12px;
      line-height: 1.6;
    }
    
    #debugPane .log-entry {
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      border-left: 3px solid #888;
    }
    
    #debugPane .log-entry.info {
      border-left-color: #4CAF50;
    }
    
    #debugPane .log-entry.error {
      border-left-color: #F44336;
      background: rgba(244, 67, 54, 0.1);
    }
    
    #debugPane .log-entry.warn {
      border-left-color: #FFC107;
    }
    
    #debugPane .log-entry .timestamp {
      color: #888;
      font-size: 11px;
      margin-right: 8px;
    }
    
    #debugPane .log-entry .message {
      color: #e0e0e0;
    }
    
    #debugPane .log-entry.error .message {
      color: #ffcdd2;
    }
    
    @media (max-width: 768px) {
      #debugPane {
        height: 50vh;
      }
      
      #debugToggle {
        width: 28px;
        height: 28px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Follow mode indicator -->
  <div id="followIndicator" class="follow-indicator">
    <span id="followIndicatorText">Following vehicle...</span>
    <button id="followIndicatorClose" class="follow-indicator-close" title="Close">‚úï</button>
  </div>
  
  <div class="ui">
    <h1>Brisbane buses ‚Äî Live</h1>
    <div class="controls">
      <div class="controls-row">
        <div class="input-wrapper">
          <input id="routeFilter" type="text" placeholder="Filter by route" />
          <button id="clearBtn" class="clear-btn" title="Clear filter">‚úï</button>
        </div>
      </div>
      <div class="controls-row">
        <button id="refreshBtn" title="Refresh">üîÑ</button>
        <button id="autoRefreshBtn" class="toggle-btn active" title="Auto-refresh (10s)">‚è±Ô∏è</button>
        <button id="locateBtn" title="My location">üìç</button>
        <button id="toggleRoutesBtn" class="toggle-btn active" title="Toggle route lines">üõ£Ô∏è</button>
        <button id="snapToRouteBtn" class="toggle-btn active" title="Snap trails to routes">üß≤</button>
        <button id="slideshowBtn" class="toggle-btn" title="Slideshow mode">üé¨</button>
      </div>
    </div>
    <div class="meta">
      <div>Current time: <span id="currentTime">‚Äî</span></div>
      <div>Last update: <span id="lastUpdate">‚Äî</span></div>
      <div>Vehicles shown: <span id="count">0</span></div>
    </div>
    <div class="legend">Source: Translink GTFS &amp; GTFS-RT (proxied) ‚Äî Carto basemap</div>
  </div>

  <!-- Status bar -->
  <div id="statusBar">Initializing...</div>

  <!-- Debug toggle icon -->
  <div id="debugToggle" title="Toggle debug logs">üêõ</div>

  <!-- Debug pane -->
  <div id="debugPane">
    <div class="debug-header">
      <span>Debug Logs</span>
      <div class="debug-controls">
        <button id="clearLogsBtn">Clear</button>
        <button id="closeDebugBtn">Close</button>
      </div>
    </div>
    <div class="debug-content" id="debugContent"></div>
  </div>

  <script src="https://unpkg.com/protobufjs@7.2.3/dist/protobuf.min.js"></script>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script>
    // Debug logging system
    const debugLogs = [];
    const MAX_DEBUG_LOGS = 500; // Limit debug logs to prevent unbounded memory growth
    const statusBarEl = document.getElementById('statusBar');
    const debugToggleEl = document.getElementById('debugToggle');
    const debugPaneEl = document.getElementById('debugPane');
    const debugContentEl = document.getElementById('debugContent');
    const clearLogsBtnEl = document.getElementById('clearLogsBtn');
    const closeDebugBtnEl = document.getElementById('closeDebugBtn');

    function updateStatus(message) {
      if (statusBarEl) {
        statusBarEl.textContent = message;
      }
      logDebug(message, 'info');
    }

    function logDebug(message, level = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = { timestamp, message, level };
      debugLogs.push(logEntry);
      
      // Limit array size to prevent unbounded growth
      if (debugLogs.length > MAX_DEBUG_LOGS) {
        debugLogs.shift();
        // Remove oldest DOM element from debug pane
        if (debugContentEl.firstChild) {
          debugContentEl.removeChild(debugContentEl.firstChild);
        }
      }
      
      // Add to debug pane
      const entryEl = document.createElement('div');
      entryEl.className = `log-entry ${level}`;
      entryEl.innerHTML = `<span class="timestamp">${timestamp}</span><span class="message">${escapeHtml(message)}</span>`;
      debugContentEl.appendChild(entryEl);
      
      // Auto-scroll to bottom
      debugContentEl.scrollTop = debugContentEl.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function hideStatusBar() {
      if (statusBarEl) {
        statusBarEl.classList.add('hidden');
      }
    }

    function lockUI() {
      // Disable all interactive UI elements during initialization
      interactiveElements.forEach(el => { if (el) el.disabled = true; });
    }

    function unlockUI() {
      // Enable all interactive UI elements after initialization
      interactiveElements.forEach(el => { if (el) el.disabled = false; });
    }

    function clearDebugLogs() {
      debugLogs.length = 0;
      debugContentEl.innerHTML = '';
    }

    // Toggle debug pane
    debugToggleEl.addEventListener('click', () => {
      debugPaneEl.classList.toggle('visible');
      debugToggleEl.classList.toggle('active');
    });

    clearLogsBtnEl.addEventListener('click', () => {
      clearDebugLogs();
      logDebug('Debug logs cleared', 'info');
    });

    closeDebugBtnEl.addEventListener('click', () => {
      debugPaneEl.classList.remove('visible');
      debugToggleEl.classList.remove('active');
    });

    // Capture console.error
    const originalConsoleError = console.error;
    console.error = function(...args) {
      logDebug('Error: ' + args.join(' '), 'error');
      originalConsoleError.apply(console, args);
    };

    // Global error handlers
    window.addEventListener('error', (event) => {
      logDebug(`Uncaught error: ${event.message} at ${event.filename}:${event.lineno}:${event.colno}`, 'error');
    });

    window.addEventListener('unhandledrejection', (event) => {
      logDebug(`Unhandled promise rejection: ${event.reason}`, 'error');
    });

    // Initialize
    logDebug('Application starting...', 'info');
    updateStatus('Initializing application...');

    // Configuration constants
    const PROXY_FEED_URL = 'https://api.codetabs.com/v1/proxy?quest=https://gtfsrt.api.translink.com.au/api/realtime/SEQ/VehiclePositions';
    // Support both GitHub Pages (/brisbus/) and local dev
    const GTFS_BASE_URL = window.location.pathname.includes('/brisbus/') ? '/brisbus/data/' : '/data/';
    const PROTO_URL = 'https://raw.githubusercontent.com/google/transit/master/gtfs-realtime/proto/gtfs-realtime.proto';
    const REFRESH_INTERVAL_MS = 10000;
    const HISTORY_WINDOW_MS = 10 * 60 * 1000; // 10 minutes for trails
    
    // Geographic and mathematical constants
    const METERS_PER_DEGREE_LAT = 111320; // Approximate meters per degree of latitude (roughly constant)
    const DEGREES_IN_CIRCLE = 360;
    const RADIANS_PER_DEGREE = Math.PI / 180;
    
    // Time conversion constants
    const SECONDS_PER_MINUTE = 60;
    const SECONDS_PER_HOUR = 3600;
    const SECONDS_PER_HALF_DAY = 12 * 3600;
    const SECONDS_PER_DAY = 24 * 3600;
    const MILLISECONDS_PER_SECOND = 1000;
    
    // Number parsing
    const DECIMAL_RADIX = 10;
    
    // Map view constants
    const FOLLOW_MODE_ZOOM = 16;
    const FOLLOW_MODE_PITCH = 60;
    const FOLLOW_MODE_INITIAL_BEARING = 0;
    
    // Animation and timing constants
    const ANIMATION_DURATION_MS = 2000;  // 2 seconds
    const SLIDESHOW_DURATION_MS = 30000; // 30 seconds per vehicle
    const ROTATION_FULL_CYCLE_SECONDS = 60; // Complete 360¬∞ rotation in 60 seconds
    const ROTATION_SPEED = DEGREES_IN_CIRCLE / ROTATION_FULL_CYCLE_SECONDS; // 6¬∞ per second - slower rotation
    const FOLLOW_MODE_FLY_DURATION_MS = 2000;
    const FOLLOW_MODE_FLY_BUFFER_MS = 100; // Small buffer after flyTo completes
    const CIRCLE_TRANSITION_DURATION_MS = 2000;
    const UI_UPDATE_INTERVAL_MS = 1000; // Update UI every second
    
    // Path calculation constants
    const MAX_SEGMENT_DIFF = 200; // Allow more segments for curves
    const MAX_REASONABLE_DISTANCE = 2000; // 2km - max distance for trail segments
    
    // Distance calculation time intervals (in seconds)
    const DISTANCE_INTERVALS_SECONDS = [10, 20, 30, 60, 120, 180, 300, 600];
    
    // GTFS route_type to emoji mapping
    // Based on GTFS specification: https://developers.google.com/transit/gtfs/reference#routestxt
    const ROUTE_TYPE_EMOJI = {
      0: 'üöä',   // Tram, Streetcar, Light rail
      1: 'üöá',   // Subway, Metro
      2: 'üöÜ',   // Rail (intercity or long-distance)
      3: 'üöå',   // Bus
      4: '‚õ¥Ô∏è',   // Ferry
      5: 'üöã',   // Cable tram
      6: 'üö°',   // Aerial lift, suspended cable car (gondola lift, aerial tramway)
      7: 'üöû',   // Funicular
      11: 'üöé',  // Trolleybus
      12: 'üöù'   // Monorail
    };
    const DEFAULT_VEHICLE_EMOJI = 'üöå'; // Default to bus if route_type is unknown

    // Get UI element references first
    const lastUpdateEl = document.getElementById('lastUpdate');
    const countEl = document.getElementById('count');
    const currentTimeEl = document.getElementById('currentTime');
    const refreshBtn = document.getElementById('refreshBtn');
    const autoRefreshBtn = document.getElementById('autoRefreshBtn');
    const routeFilterEl = document.getElementById('routeFilter');
    const clearBtn = document.getElementById('clearBtn');
    const locateBtn = document.getElementById('locateBtn');
    const toggleRoutesBtn = document.getElementById('toggleRoutesBtn');
    const snapToRouteBtn = document.getElementById('snapToRouteBtn');
    const slideshowBtn = document.getElementById('slideshowBtn');
    const followIndicator = document.getElementById('followIndicator');
    const followIndicatorText = document.getElementById('followIndicatorText');

    // Array of all interactive UI elements to enable/disable
    const interactiveElements = [
      routeFilterEl,
      refreshBtn,
      autoRefreshBtn,
      locateBtn,
      toggleRoutesBtn,
      snapToRouteBtn,
      slideshowBtn,
      clearBtn
    ];

    // Lock UI during initialization (before any external library calls)
    lockUI();

    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [153.0251, -27.4679],
      zoom: 11
    });
    map.addControl(new maplibregl.NavigationControl({showCompass: false}), 'top-right');

    let root = null, feedMessageType = null;
    let vehiclesGeoJSON = { type: 'FeatureCollection', features: [] };
    let vehicleHistory = {}; // vehicle_id ‚Üí array of {coords, timestamp, speed}
    let allShapes = {};      // shape_id ‚Üí Feature
    let routeToShapes = {};  // route_id ‚Üí Set(shape_id)
    let tripToShape = {};    // trip_id ‚Üí shape_id
    let allStops = {};       // stop_id ‚Üí {lat, lon, name, ...}
    let tripStopTimes = {};  // trip_id ‚Üí array of {stop_id, arrival_time (seconds), departure_time (seconds), stop_sequence}
    let routeStops = {};     // route_id ‚Üí Set(stop_id)
    let routeTypes = {};     // route_id ‚Üí route_type (GTFS route type)
    let autoTimer = null;
    let userLocation = { type: 'FeatureCollection', features: [] };
    let showRoutes = true;  // Track whether to show route lines
    let snapToRoute = true;  // Track whether to snap trails to routes
    let cachedFilterText = ''; // Cache the current filter text
    
    // Animation state
    let animationStartTime = null;
    let animationInProgress = false;
    let previousPositions = {};  // vehicle_id ‚Üí coordinates
    let targetPositions = {};    // vehicle_id ‚Üí coordinates
    let animationPaths = {};     // vehicle_id ‚Üí array of coordinates (path to follow)
    
    // Slideshow/follow mode state
    let slideshowActive = false;
    let followModeActive = false;
    let slideshowTimer = null;
    let rotationAnimationId = null; // Changed from rotationTimer to animationId
    let currentFollowedVehicle = null;
    let currentRotationAngle = 0;
    let currentFollowPopup = null; // Track current popup for updates
    let rotationStartTime = null; // Track when rotation started

    // Update current time every second
    function updateCurrentTime() {
      const now = new Date();
      currentTimeEl.textContent = now.toLocaleTimeString();
    }
    updateCurrentTime();
    setInterval(updateCurrentTime, UI_UPDATE_INTERVAL_MS);

    async function loadProto() {
      updateStatus('Loading protocol buffer definition...');
      const res = await fetch(PROTO_URL);
      const protoText = await res.text();
      const parsed = protobuf.parse(protoText);
      root = parsed.root;
      feedMessageType = root.lookupType('transit_realtime.FeedMessage');
      logDebug('Protocol buffer definition loaded successfully', 'info');
    }

    /**
     * Fetch and decompress a GTFS file
     * Uses brotli for WebKit browsers, gzip for everything else
     * Falls back to uncompressed file if compressed version is not available
     * WebKit has better brotli support via DecompressionStream
     */
    async function fetchAndDecompress(filename) {
      // Detect compression format based on browser
      const isWebKit = /WebKit/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
      const compressionFormat = isWebKit ? 'brotli' : 'gzip';
      const fileExtension = isWebKit ? '.br' : '.gz';
      
      // Try compressed file first
      const compressedUrl = `${GTFS_BASE_URL}${filename}${fileExtension}`;
      logDebug(`Fetching ${filename}${fileExtension}...`, 'info');
      const compressedRes = await fetch(compressedUrl);
      
      if (compressedRes.ok) {
        const ds = new DecompressionStream(compressionFormat);
        const decompressedStream = compressedRes.body.pipeThrough(ds);
        const decompressed = await new Response(decompressedStream).arrayBuffer();
        const text = new TextDecoder().decode(decompressed);
        logDebug(`Successfully loaded and decompressed ${filename}${fileExtension}`, 'info');
        return text;
      }
      
      // Fallback to uncompressed file
      logDebug(`Compressed file not found, fetching uncompressed ${filename}...`, 'info');
      const uncompressedUrl = `${GTFS_BASE_URL}${filename}`;
      const uncompressedRes = await fetch(uncompressedUrl);
      
      if (!uncompressedRes.ok) {
        throw new Error(`Failed to fetch ${filename}: HTTP ${uncompressedRes.status}`);
      }
      
      const text = await uncompressedRes.text();
      logDebug(`Successfully loaded uncompressed ${filename}`, 'info');
      return text;
    }

    /**
     * Parse a CSV line properly handling quoted fields with commas
     * @param {string} line - A single CSV line
     * @returns {string[]} - Array of field values
     */
    function parseCSVLine(line) {
      const fields = [];
      let currentField = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
          // Toggle quote state
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          // End of field
          fields.push(currentField);
          currentField = '';
        } else {
          // Add character to current field
          currentField += char;
        }
      }
      
      // Add the last field
      fields.push(currentField);
      
      return fields;
    }

    /**
     * Load and parse shapes data
     */
    async function loadAndParseShapes() {
      const shapesTxt = await fetchAndDecompress('shapes.txt');
      
      updateStatus('Parsing shapes data...');
      const lines = shapesTxt.trim().split(/\r?\n/);
      const headers = parseCSVLine(lines.shift());
      const idx = Object.fromEntries(headers.map((h,i)=>[h,i]));
      const tmp = {};
      for (const line of lines) {
        const parts = parseCSVLine(line);
        const sid = parts[idx["shape_id"]];
        const lat = parseFloat(parts[idx["shape_pt_lat"]]);
        const lon = parseFloat(parts[idx["shape_pt_lon"]]);
        const seq = parseInt(parts[idx["shape_pt_sequence"]], DECIMAL_RADIX);
        if (!tmp[sid]) tmp[sid] = [];
        tmp[sid].push({seq, coord:[lon,lat]});
      }
      // Process shapes and free tmp memory progressively
      for (const sid in tmp) {
        tmp[sid].sort((a,b)=>a.seq-b.seq);
        const coords = new Array(tmp[sid].length);
        for (let i = 0; i < tmp[sid].length; i++) {
          coords[i] = tmp[sid][i].coord;
        }
        allShapes[sid] = {
          type:"Feature",
          geometry:{type:"LineString", coordinates:coords},
          properties:{shape_id:sid}
        };
        // Free memory for this shape's temp data
        delete tmp[sid];
      }
      logDebug(`Parsed ${Object.keys(allShapes).length} shapes`, 'info');
    }

    /**
     * Load and parse routes data to extract route_type information
     */
    async function loadAndParseRoutes() {
      const routesTxt = await fetchAndDecompress('routes.txt');
      
      updateStatus('Parsing routes data...');
      let firstLine = true;
      let ridx = {};
      
      // Parse line by line to avoid keeping full array in memory
      const lines = routesTxt.split(/\r?\n/);
      for (const line of lines) {
        if (!line.trim()) continue;
        
        if (firstLine) {
          const rheaders = parseCSVLine(line);
          ridx = Object.fromEntries(rheaders.map((h,i)=>[h,i]));
          firstLine = false;
          continue;
        }
        
        const parts = parseCSVLine(line);
        const routeId = parts[ridx["route_id"]];
        const routeType = parts[ridx["route_type"]];
        if (routeId && routeType !== undefined) {
          routeTypes[routeId] = parseInt(routeType, DECIMAL_RADIX);
        }
      }
      logDebug(`Parsed ${Object.keys(routeTypes).length} routes with types`, 'info');
    }

    /**
     * Load and parse trips data
     */
    async function loadAndParseTrips() {
      const tripsTxt = await fetchAndDecompress('trips.txt');
      
      updateStatus('Parsing trips data...');
      let firstLine = true;
      let tidx = {};
      const tripToRoute = {}; // trip_id ‚Üí route_id
      
      // Parse line by line to avoid keeping full array in memory
      const lines = tripsTxt.split(/\r?\n/);
      for (const line of lines) {
        if (!line.trim()) continue;
        
        if (firstLine) {
          const theaders = parseCSVLine(line);
          tidx = Object.fromEntries(theaders.map((h,i)=>[h,i]));
          firstLine = false;
          continue;
        }
        
        const parts = parseCSVLine(line);
        const rid = parts[tidx["route_id"]];
        const sid = parts[tidx["shape_id"]];
        const tripId = parts[tidx["trip_id"]];
        if (!rid || !sid) continue;
        if (!routeToShapes[rid]) routeToShapes[rid] = new Set();
        routeToShapes[rid].add(sid);
        if (tripId) {
          tripToRoute[tripId] = rid;
          tripToShape[tripId] = sid;
        }
      }
      logDebug(`Parsed ${Object.keys(routeToShapes).length} route mappings`, 'info');
      return tripToRoute;
    }

    /**
     * Load and parse stops data
     */
    async function loadAndParseStops() {
      const stopsTxt = await fetchAndDecompress('stops.txt');
      
      updateStatus('Parsing stops data...');
      let firstLine = true;
      let stopIdx = {};
      
      const lines = stopsTxt.split(/\r?\n/);
      for (const line of lines) {
        if (!line.trim()) continue;
        
        if (firstLine) {
          const stopHeaders = parseCSVLine(line);
          stopIdx = Object.fromEntries(stopHeaders.map((h,i)=>[h,i]));
          firstLine = false;
          continue;
        }
        
        const parts = parseCSVLine(line);
        const stopId = parts[stopIdx["stop_id"]];
        const stopName = parts[stopIdx["stop_name"]] || '';
        const stopLat = parseFloat(parts[stopIdx["stop_lat"]]);
        const stopLon = parseFloat(parts[stopIdx["stop_lon"]]);
        if (stopId && !isNaN(stopLat) && !isNaN(stopLon)) {
          allStops[stopId] = {
            id: stopId,
            name: stopName,
            lat: stopLat,
            lon: stopLon
          };
        }
      }
      logDebug(`Parsed ${Object.keys(allStops).length} stops`, 'info');
    }

    /**
     * Load and parse stop times data
     * Optimized to reduce memory usage by converting time strings to integers (seconds since midnight)
     */
    async function loadAndParseStopTimes(tripToRoute) {
      const stopTimesTxt = await fetchAndDecompress('stop_times.txt');
      
      updateStatus('Parsing stop times data...');
      let firstLine = true;
      let stopTimeIdx = {};
      
      const lines = stopTimesTxt.split(/\r?\n/);
      for (const line of lines) {
        if (!line.trim()) continue;
        
        if (firstLine) {
          const stopTimeHeaders = parseCSVLine(line);
          stopTimeIdx = Object.fromEntries(stopTimeHeaders.map((h,i)=>[h,i]));
          firstLine = false;
          continue;
        }
        
        const parts = parseCSVLine(line);
        const tripId = parts[stopTimeIdx["trip_id"]];
        const stopId = parts[stopTimeIdx["stop_id"]];
        const arrivalTimeStr = parts[stopTimeIdx["arrival_time"]];
        const departureTimeStr = parts[stopTimeIdx["departure_time"]];
        const stopSequence = parseInt(parts[stopTimeIdx["stop_sequence"]], DECIMAL_RADIX);
        
        if (tripId && stopId && arrivalTimeStr) {
          // Convert time strings to seconds (integer)
          const arrivalTimeSeconds = parseGtfsTime(arrivalTimeStr);
          const departureTimeSeconds = departureTimeStr ? parseGtfsTime(departureTimeStr) : arrivalTimeSeconds;
          
          if (!tripStopTimes[tripId]) tripStopTimes[tripId] = [];
          tripStopTimes[tripId].push({
            stop_id: stopId,
            arrival_time: arrivalTimeSeconds,  // Now stored as integer (seconds)
            departure_time: departureTimeSeconds,  // Now stored as integer (seconds)
            stop_sequence: stopSequence
          });
          
          // Build route -> stops mapping
          const routeId = tripToRoute[tripId];
          if (routeId) {
            if (!routeStops[routeId]) routeStops[routeId] = new Set();
            routeStops[routeId].add(stopId);
          }
        }
      }
      logDebug(`Parsed stop times for ${Object.keys(tripStopTimes).length} trips`, 'info');
    }

    /**
     * Load emoji images into the map
     * Creates canvas-based images for each emoji icon
     */
    function loadEmojiImages() {
      updateStatus('Loading vehicle emoji icons...');
      
      // Map of emoji names to emoji characters
      const emojiMap = {
        'tram-emoji': 'üöä',
        'subway-emoji': 'üöá',
        'rail-emoji': 'üöÜ',
        'bus-emoji': 'üöå',
        'ferry-emoji': '‚õ¥Ô∏è',
        'cable-tram-emoji': 'üöã',
        'aerial-lift-emoji': 'üö°',
        'funicular-emoji': 'üöû',
        'trolleybus-emoji': 'üöé',
        'monorail-emoji': 'üöù'
      };
      
      // Load each emoji as an image
      for (const [name, emoji] of Object.entries(emojiMap)) {
        // Create a canvas to render the emoji
        const size = 64;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        // Draw emoji on canvas
        ctx.font = `${size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, size / 2, size / 2);
        
        // Add the canvas as an image to the map
        if (!map.hasImage(name)) {
          map.addImage(name, ctx.getImageData(0, 0, size, size));
        }
      }
      
      logDebug('Loaded emoji images for vehicle types', 'info');
    }

    async function loadGTFS() {
      updateStatus('Loading GTFS data...');
      logDebug('Starting GTFS data load', 'info');
      
      // Load shapes, routes, trips, and stops in parallel for faster initial load
      // Memory is now optimized with integer times and time-window filtering
      updateStatus('Downloading and parsing GTFS data...');
      const [_, __, tripToRoute, ___] = await Promise.all([
        loadAndParseShapes(),
        loadAndParseRoutes(),
        loadAndParseTrips(),
        loadAndParseStops()
      ]);

      // Parse stop_times after trips are loaded (needs tripToRoute mapping)
      await loadAndParseStopTimes(tripToRoute);

      // Initialise empty layer
      updateStatus('Initializing map layers...');
      map.addSource("routes",{type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"route-lines",
        type:"line",
        source:"routes",
        paint:{
          "line-color":"#0077cc",
          "line-width":2,
          "line-opacity":0.6
        }
      });

      // Initialise stops layer
      map.addSource("stops", {type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"stop-circles",
        type:"circle",
        source:"stops",
        paint:{
          "circle-radius":3,
          "circle-color":"#9E9E9E",
          "circle-stroke-width":1,
          "circle-stroke-color":"#fff",
          "circle-opacity":0.7
        }
      });

      // Initialise user location layer
      map.addSource("user-location", { type: "geojson", data: userLocation });
      map.addLayer({
        id:"user-location-circle",
        type:"circle",
        source:"user-location",
        paint:{
          "circle-radius":7,
          "circle-color":"#0066ff",
          "circle-stroke-width":2,
          "circle-stroke-color":"#fff"
        }
      });
      logDebug('Map layers initialized', 'info');
    }

    async function fetchFeedAndUpdate() {
      try {
        logDebug('Fetching vehicle positions...', 'info');
        const res = await fetch(PROXY_FEED_URL, {cache: 'no-store'});
        if (!res.ok) throw new Error('Network response not ok: ' + res.status);
        const buffer = await res.arrayBuffer();
        const uint8 = new Uint8Array(buffer);
        const message = feedMessageType.decode(uint8);
        const object = feedMessageType.toObject(message, { longs: String, enums: String, bytes: String });
        const geojson = feedToGeoJSON(object);
        updateHistory(geojson);
        
        // Check if this is the first load (source doesn't exist yet)
        if (!map.getSource('vehicles')) {
          // First load: set up layers without animation
          vehiclesGeoJSON = geojson;
          updateMapSource();
        } else {
          // Subsequent updates: use smooth animation for position updates
          startPositionAnimation(geojson);
          
          // Update trails and routes (these don't need animation)
          updateMapSourceNonAnimated();
        }
        
        // Display time with seconds
        const now = new Date();
        lastUpdateEl.textContent = now.toLocaleTimeString();
        countEl.textContent = geojson.features.length;
        logDebug(`Updated ${geojson.features.length} vehicle positions`, 'info');
      } catch (err) {
        logDebug('Error fetching feed: ' + err.message, 'error');
        lastUpdateEl.textContent = 'Error fetching feed';
      }
    }

    function feedToGeoJSON(feedObj) {
      const feats = [];
      if (!feedObj || !feedObj.entity) return { type: 'FeatureCollection', features: [] };
      for (const e of feedObj.entity) {
        if (!e.vehicle) continue;
        const vp = e.vehicle.position;
        if (!vp || vp.latitude == null || vp.longitude == null) continue;
        const vehicleId = e.id || (e.vehicle.vehicle && e.vehicle.vehicle.id) || null;
        const routeId = e.vehicle.trip && e.vehicle.trip.routeId || null;
        const routeType = routeId ? routeTypes[routeId] : null;
        const props = {
          id: vehicleId,
          label: (e.vehicle.trip && e.vehicle.trip.routeId && e.vehicle.trip.routeId.split("-")[0]) || null,
          human_readable_id: (e.vehicle.vehicle && e.vehicle.vehicle.label) || null,
          route_id: routeId,
          trip_id: e.vehicle.trip && e.vehicle.trip.tripId || null,
          bearing: vp.bearing || null,
          speed: vp.speed || null,
          current_stop_sequence: e.vehicle.currentStopSequence || null,
          timestamp: e.vehicle.timestamp || null,
          route_type: routeType !== null && routeType !== undefined ? routeType : 3  // Default to bus (3) if unknown
        };
        feats.push({
          type: 'Feature',
          id: vehicleId,  // Add feature ID for smooth animations
          geometry: { type: 'Point', coordinates: [vp.longitude, vp.latitude] },
          properties: props
        });
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function updateHistory(currentGeoJSON) {
      const now = Date.now();
      const activeVehicleIds = new Set();
      
      for (const f of currentGeoJSON.features) {
        if (f.properties.timestamp && f.properties.id) {
          const vehicleId = f.properties.id;
          activeVehicleIds.add(vehicleId);
          const tsMs = Number(f.properties.timestamp) * 1000;
          
          if (!vehicleHistory[vehicleId]) {
            vehicleHistory[vehicleId] = [];
          }
          
          // Add new position if it's not a duplicate
          const history = vehicleHistory[vehicleId];
          const isDuplicate = history.length > 0 && 
            history[history.length - 1].timestamp === tsMs;
          
          if (!isDuplicate) {
            history.push({
              coords: f.geometry.coordinates,
              timestamp: tsMs,
              speed: f.properties.speed || 0,
              route_id: f.properties.route_id,
              trip_id: f.properties.trip_id,
              label: f.properties.label
            });
          }
        }
      }
      
      // Clean up old positions and empty vehicles
      for (const vehicleId in vehicleHistory) {
        vehicleHistory[vehicleId] = vehicleHistory[vehicleId].filter(
          pos => now - pos.timestamp <= HISTORY_WINDOW_MS
        );
        if (vehicleHistory[vehicleId].length === 0) {
          delete vehicleHistory[vehicleId];
          // Also clean up animation state for removed vehicles
          delete previousPositions[vehicleId];
          delete targetPositions[vehicleId];
        }
      }
      
      // Clean up animation positions for vehicles no longer in history
      for (const vehicleId in previousPositions) {
        if (!vehicleHistory[vehicleId]) {
          delete previousPositions[vehicleId];
        }
      }
      for (const vehicleId in targetPositions) {
        if (!vehicleHistory[vehicleId]) {
          delete targetPositions[vehicleId];
        }
      }
    }

    function applyFilter(geojson) {
      if (!cachedFilterText) return geojson;
      return {
        type: 'FeatureCollection',
        features: geojson.features.filter(f => {
          return (f.properties.route_id && f.properties.route_id.toLowerCase().includes(cachedFilterText)) ||
                 (f.properties.label && f.properties.label.toLowerCase().includes(cachedFilterText));
        })
      };
    }

    /**
     * Find the nearest point on a line (shape) to a given coordinate
     * Returns { point: [lon, lat], segmentIndex: number, distance: number }
     */
    function findNearestPointOnShape(coord, shapeCoords) {
      let minDist = Infinity;
      let nearestPoint = null;
      let nearestSegmentIndex = -1;
      
      for (let i = 0; i < shapeCoords.length - 1; i++) {
        const segStart = shapeCoords[i];
        const segEnd = shapeCoords[i + 1];
        const result = nearestPointOnSegment(coord, segStart, segEnd);
        
        if (result.distance < minDist) {
          minDist = result.distance;
          nearestPoint = result.point;
          nearestSegmentIndex = i;
        }
      }
      
      return { point: nearestPoint, segmentIndex: nearestSegmentIndex, distance: minDist };
    }

    /**
     * Find the nearest point on a line segment to a given coordinate
     * Returns { point: [lon, lat], distance: number }
     */
    function nearestPointOnSegment(coord, segStart, segEnd) {
      const [lon, lat] = coord;
      const [lon1, lat1] = segStart;
      const [lon2, lat2] = segEnd;
      
      // Handle degenerate case where segment is a point
      if (lon1 === lon2 && lat1 === lat2) {
        const dist = haversineDistance(lat, lon, lat1, lon1);
        return { point: [lon1, lat1], distance: dist };
      }
      
      // For geographic coordinates, we need to work in meters, not degrees
      // We'll use a simple approach: convert to approximate meters using a local projection
      const latMid = (lat1 + lat2) / 2;
      const metersPerDegreeLat = METERS_PER_DEGREE_LAT;
      const metersPerDegreeLon = METERS_PER_DEGREE_LAT * Math.cos(latMid * RADIANS_PER_DEGREE);
      
      // Convert to meters (approximate local projection)
      const px = (lon - lon1) * metersPerDegreeLon;
      const py = (lat - lat1) * metersPerDegreeLat;
      const dx = (lon2 - lon1) * metersPerDegreeLon;
      const dy = (lat2 - lat1) * metersPerDegreeLat;
      
      // Calculate the parameter t that represents the projection of point P onto the line
      const t = Math.max(0, Math.min(1, (px * dx + py * dy) / (dx * dx + dy * dy)));
      
      // Calculate the nearest point in degrees
      const nearestLon = lon1 + t * (lon2 - lon1);
      const nearestLat = lat1 + t * (lat2 - lat1);
      
      // Calculate actual distance using haversine
      const dist = haversineDistance(lat, lon, nearestLat, nearestLon);
      return { point: [nearestLon, nearestLat], distance: dist };
    }

    /**
     * Get the path along a shape from one segment index to another
     * Returns an array of coordinates following the shape, or null if path is unreasonable
     */
    function getPathAlongShape(shapeCoords, startPoint, startSegIdx, endPoint, endSegIdx) {
      const path = [];
      
      // Calculate the number of segments we'll traverse
      const segmentDiff = Math.abs(endSegIdx - startSegIdx);
      
      // Safety check: if too many segments, calculate actual distance along route
      // to determine if this is a reasonable path
      if (segmentDiff > MAX_SEGMENT_DIFF) {
        // Calculate total distance along the route path
        let totalDist = 0;
        const forward = endSegIdx > startSegIdx;
        
        if (forward) {
          for (let i = startSegIdx; i < endSegIdx && i < shapeCoords.length - 1; i++) {
            const [lon1, lat1] = shapeCoords[i];
            const [lon2, lat2] = shapeCoords[i + 1];
            totalDist += haversineDistance(lat1, lon1, lat2, lon2);
          }
        } else {
          for (let i = startSegIdx; i > endSegIdx && i > 0; i--) {
            const [lon1, lat1] = shapeCoords[i];
            const [lon2, lat2] = shapeCoords[i - 1];
            totalDist += haversineDistance(lat1, lon1, lat2, lon2);
          }
        }
        
        // If the total distance is more than 2km, this is likely a data issue
        // (e.g., vehicle jumped to different part of route, or sparse GPS data)
        // Return null to indicate we shouldn't draw this segment
        if (totalDist > MAX_REASONABLE_DISTANCE) {
          logDebug(`Skipping trail segment: route distance ${totalDist.toFixed(0)}m exceeds ${MAX_REASONABLE_DISTANCE}m (${segmentDiff} segments)`, 'warn');
          return null;
        }
      }
      
      // Add the start point
      path.push(startPoint);
      
      // If same segment, just connect start to end
      if (startSegIdx === endSegIdx) {
        path.push(endPoint);
        return path;
      }
      
      // For different segments, include all intermediate shape points (including corners)
      const forward = endSegIdx > startSegIdx;
      
      if (forward) {
        // Moving forward along the shape
        // Include all shape points from startSegIdx+1 to endSegIdx (inclusive)
        for (let i = startSegIdx + 1; i <= endSegIdx; i++) {
          path.push(shapeCoords[i]);
        }
      } else {
        // Moving backward along the shape
        // Include all shape points from startSegIdx to endSegIdx+1 (in reverse)
        for (let i = startSegIdx; i >= endSegIdx + 1; i--) {
          path.push(shapeCoords[i]);
        }
      }
      
      // Add the end point
      path.push(endPoint);
      
      return path;
    }


    function buildTrailsGeoJSON() {
      const features = [];
      
      for (const vehicleId in vehicleHistory) {
        const history = vehicleHistory[vehicleId];
        if (history.length < 2) continue; // Need at least 2 points for a line
        
        // Apply filter
        if (cachedFilterText) {
          const lastPos = history[history.length - 1];
          const matchesFilter = 
            (lastPos.route_id && lastPos.route_id.toLowerCase().includes(cachedFilterText)) ||
            (lastPos.label && lastPos.label.toLowerCase().includes(cachedFilterText));
          if (!matchesFilter) continue;
        }
        
        // Calculate average speed for the trail
        let avgSpeed = 0;
        let speedCount = 0;
        let speedSum = 0;
        
        // First try to use reported speeds if available
        for (let i = 0; i < history.length; i++) {
          const speed = history[i].speed;
          if (speed && speed > 0) {
            speedSum += speed;
            speedCount++;
          }
        }
        
        if (speedCount > 0) {
          avgSpeed = speedSum / speedCount;
        } else if (history.length >= 2) {
          // If no reported speeds, calculate from position changes
          let totalDistance = 0;
          let totalTime = 0;
          
          for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            const timeDiff = (curr.timestamp - prev.timestamp) / 1000; // seconds
            
            if (timeDiff > 0) {
              const dist = haversineDistance(
                prev.coords[1], prev.coords[0],
                curr.coords[1], curr.coords[0]
              );
              totalDistance += dist;
              totalTime += timeDiff;
            }
          }
          
          if (totalTime > 0) {
            avgSpeed = totalDistance / totalTime; // meters per second
          }
        }
        
        // Get the shape for this vehicle's trip
        // Use the most recent trip_id to handle potential trip changes during history window
        const lastPos = history[history.length - 1];
        const tripId = lastPos.trip_id;
        const shapeId = tripId ? tripToShape[tripId] : null;
        const shape = shapeId ? allShapes[shapeId] : null;
        const shapeCoords = shape ? shape.geometry.coordinates : null;
        
        let coords = [];
        
        // Route-following algorithm: snap positions to route and follow shape segments
        // This ensures lines follow actual route curves instead of cutting corners
        // Only apply if snapToRoute is enabled
        if (snapToRoute && shapeCoords && shapeCoords.length >= 2) {
          const SNAP_THRESHOLD_M = 100; // 100m threshold for snapping to route
          
          // Pre-compute nearest points for all history positions to avoid redundant calculations
          const nearestResults = new Array(history.length);
          for (let i = 0; i < history.length; i++) {
            nearestResults[i] = findNearestPointOnShape(history[i].coords, shapeCoords);
          }
          
          // Build trail segments - may create multiple disconnected segments
          let currentSegment = [];
          const segments = [];
          
          for (let i = 0; i < history.length; i++) {
            const pos = history[i];
            const nearestResult = nearestResults[i];
            
            // Check if this position has the same trip_id (to handle trip changes)
            const sameTripId = !pos.trip_id || pos.trip_id === tripId;
            
            // Only include points that are on the route (within 100m) and same trip
            if (sameTripId && nearestResult.distance <= SNAP_THRESHOLD_M) {
              if (currentSegment.length === 0) {
                // Starting a new segment
                currentSegment.push(nearestResult.point);
              } else {
                // Extending current segment: trace the route from previous position
                const prevPos = history[i - 1];
                const prevNearestResult = nearestResults[i - 1];
                const prevSameTripId = !prevPos.trip_id || prevPos.trip_id === tripId;
                
                if (prevSameTripId && prevNearestResult.distance <= SNAP_THRESHOLD_M) {
                  // Both points are on route - follow the shape segments between them
                  const pathSegment = getPathAlongShape(
                    shapeCoords,
                    currentSegment[currentSegment.length - 1], // Use the last coord we added
                    prevNearestResult.segmentIndex,
                    nearestResult.point,
                    nearestResult.segmentIndex
                  );
                  
                  if (pathSegment !== null) {
                    // Add all points except the first (which is already in currentSegment)
                    for (let j = 1; j < pathSegment.length; j++) {
                      currentSegment.push(pathSegment[j]);
                    }
                  } else {
                    // Path was unreasonable - finalize current segment and start a new one
                    if (currentSegment.length >= 2) {
                      segments.push([...currentSegment]);
                    }
                    currentSegment = [nearestResult.point];
                  }
                } else {
                  // Previous point was off-route or different trip
                  // Finalize current segment and start a new one
                  if (currentSegment.length >= 2) {
                    segments.push([...currentSegment]);
                  }
                  currentSegment = [nearestResult.point];
                }
              }
            } else {
              // Point is off-route - finalize current segment if it has enough points
              if (currentSegment.length >= 2) {
                segments.push([...currentSegment]);
              }
              currentSegment = [];
            }
          }
          
          // Don't forget the last segment
          if (currentSegment.length >= 2) {
            segments.push([...currentSegment]);
          }
          
          // Create a feature for each segment
          for (const segmentCoords of segments) {
            features.push({
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: segmentCoords
              },
              properties: {
                vehicle_id: vehicleId,
                speed: avgSpeed
              }
            });
          }
          
          // Skip the normal feature creation below
          continue;
        } else {
          // Fallback: no shape available, use raw coordinates
          coords = new Array(history.length);
          for (let i = 0; i < history.length; i++) {
            coords[i] = history[i].coords;
          }
        }
        
        // Only create a feature if we have at least 2 points
        if (coords.length < 2) continue;
        
        features.push({
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: coords
          },
          properties: {
            vehicle_id: vehicleId,
            speed: avgSpeed
          }
        });
      }
      
      return { type: 'FeatureCollection', features };
    }

    function calculateDistances(vehicleId) {
      const history = vehicleHistory[vehicleId];
      if (!history || history.length < 2) return [];
      
      const now = Date.now();
      const distances = [];
      const intervals = DISTANCE_INTERVALS_SECONDS;
      
      for (const interval of intervals) {
        const targetTime = now - (interval * MILLISECONDS_PER_SECOND);
        
        // Find the closest position in history to this time
        let closestPos = null;
        let minDiff = Infinity;
        
        for (const pos of history) {
          const diff = Math.abs(pos.timestamp - targetTime);
          if (diff < minDiff) {
            minDiff = diff;
            closestPos = pos;
          }
        }
        
        // Calculate distance if we found a position
        if (closestPos && minDiff < interval * 500) { // within half the interval
          const currentPos = history[history.length - 1];
          const distance = haversineDistance(
            closestPos.coords[1], closestPos.coords[0],
            currentPos.coords[1], currentPos.coords[0]
          );
          
          if (distance > 0) {
            const actualTimeDiff = (currentPos.timestamp - closestPos.timestamp) / 1000; // seconds
            const speedMps = actualTimeDiff > 0 ? distance / actualTimeDiff : 0; // m/s
            const speedKmh = Math.round(speedMps * 3.6); // convert to km/h
            distances.push({ 
              interval, 
              distance: Math.round(distance),
              speedKmh 
            });
          }
        }
      }
      
      return distances;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const dLat = (lat2 - lat1) * RADIANS_PER_DEGREE;
      const dLon = (lon2 - lon1) * RADIANS_PER_DEGREE;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * RADIANS_PER_DEGREE) * Math.cos(lat2 * RADIANS_PER_DEGREE) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    /**
     * Parse GTFS time string (HH:MM:SS) to seconds since midnight
     * Handles times >= 24:00:00 (next day service)
     */
    function parseGtfsTime(timeStr) {
      if (!timeStr) return null;
      const parts = timeStr.split(':');
      if (parts.length !== 3) return null;
      const hours = parseInt(parts[0], DECIMAL_RADIX);
      const minutes = parseInt(parts[1], DECIMAL_RADIX);
      const seconds = parseInt(parts[2], DECIMAL_RADIX);
      return hours * SECONDS_PER_HOUR + minutes * SECONDS_PER_MINUTE + seconds;
    }

    /**
     * Get current time in seconds since midnight (handles day wraparound)
     */
    function getCurrentTimeSeconds() {
      const now = new Date();
      return now.getHours() * SECONDS_PER_HOUR + now.getMinutes() * SECONDS_PER_MINUTE + now.getSeconds();
    }

    /**
     * Calculate the delay in seconds for a vehicle based on scheduled vs actual position
     */
    function calculateVehicleDelay(stopTimes, currentStopSeq, vehicleTimestamp) {
      if (!stopTimes || !currentStopSeq || !vehicleTimestamp) return null;
      
      // Find the scheduled time for the current stop
      const currentStopTime = stopTimes.find(st => st.stop_sequence === currentStopSeq);
      if (!currentStopTime || !currentStopTime.arrival_time) return null;
      
      // arrival_time is now already in seconds (integer)
      const scheduledSeconds = currentStopTime.arrival_time;
      
      // Get actual time from vehicle timestamp
      const actualDate = new Date(Number(vehicleTimestamp) * MILLISECONDS_PER_SECOND);
      const actualSeconds = actualDate.getHours() * SECONDS_PER_HOUR + actualDate.getMinutes() * SECONDS_PER_MINUTE + actualDate.getSeconds();
      
      // Calculate delay (positive = late, negative = early)
      // Handle day wraparound for late-night services
      let delay = actualSeconds - scheduledSeconds;
      if (delay > SECONDS_PER_HALF_DAY) delay -= SECONDS_PER_DAY; // Crossed midnight forward
      if (delay < -SECONDS_PER_HALF_DAY) delay += SECONDS_PER_DAY; // Crossed midnight backward
      
      return delay;
    }

    // Calculate upcoming arrivals at a stop within the next 30 minutes
    function getUpcomingArrivals(stopId) {
      const arrivals = [];
      const now = Date.now();
      const thirtyMinutesFromNow = now + (30 * 60 * 1000);
      const currentTimeSeconds = getCurrentTimeSeconds();
      
      // Iterate through all current vehicles
      for (const feature of vehiclesGeoJSON.features) {
        const vehicleProps = feature.properties;
        const tripId = vehicleProps.trip_id;
        const currentStopSeq = vehicleProps.current_stop_sequence;
        const routeId = vehicleProps.route_id;
        const vehicleTimestamp = vehicleProps.timestamp;
        
        if (!tripId || !currentStopSeq) continue;
        
        // Get stop times for this trip
        const stopTimes = tripStopTimes[tripId];
        if (!stopTimes) continue;
        
        // Find the stop in this trip
        const stopTime = stopTimes.find(st => st.stop_id === stopId && st.stop_sequence >= currentStopSeq);
        if (!stopTime) continue;
        
        const stopsToGo = stopTime.stop_sequence - currentStopSeq;
        
        // Try to calculate ETA using scheduled times and current delay
        let estimatedMinutes = null;
        let estimatedArrival = null;
        
        if (stopTime.arrival_time && vehicleTimestamp) {
          // arrival_time is now already in seconds (integer)
          const scheduledArrivalSeconds = stopTime.arrival_time;
          
          // Calculate current delay
          const delay = calculateVehicleDelay(stopTimes, currentStopSeq, vehicleTimestamp);
          
          if (delay !== null) {
            // Apply delay to scheduled arrival time
            const estimatedArrivalSeconds = scheduledArrivalSeconds + delay;
            
            // Calculate time difference from now
            let secondsUntilArrival = estimatedArrivalSeconds - currentTimeSeconds;
            
            // Handle day wraparound
            if (secondsUntilArrival < -12 * 3600) secondsUntilArrival += 24 * 3600;
            if (secondsUntilArrival > 12 * 3600) secondsUntilArrival -= 24 * 3600;
            
            // Convert to milliseconds for arrival time
            estimatedArrival = now + (secondsUntilArrival * 1000);
            estimatedMinutes = secondsUntilArrival / 60;
          }
        }
        
        // Fallback to simple stop-counting method if scheduled data unavailable
        if (estimatedMinutes === null) {
          estimatedMinutes = stopsToGo * 2;
          estimatedArrival = now + (estimatedMinutes * 60 * 1000);
        }
        
        // Only include if within 30 minutes and not already passed
        if (estimatedArrival <= thirtyMinutesFromNow && estimatedMinutes >= 0) {
          arrivals.push({
            route_id: routeId,
            vehicle_label: vehicleProps.label,
            vehicle_id: vehicleProps.id,
            eta_minutes: Math.round(estimatedMinutes),
            stops_away: stopsToGo
          });
        }
      }
      
      // Sort by ETA
      arrivals.sort((a, b) => a.eta_minutes - b.eta_minutes);
      return arrivals;
    }

    // Build stops GeoJSON based on current filters
    function buildStopsGeoJSON() {
      const features = [];
      
      // Determine which stops to show based on route filter
      let stopIdsToShow = new Set();
      
      if (cachedFilterText) {
        // Show stops for filtered routes
        for (const rid in routeStops) {
          if (rid.toLowerCase().includes(cachedFilterText)) {
            routeStops[rid].forEach(stopId => stopIdsToShow.add(stopId));
          }
        }
      } else {
        // Show stops for routes that have active vehicles
        const filteredVehicles = applyFilter(vehiclesGeoJSON);
        filteredVehicles.features.forEach(f => {
          const routeId = f.properties.route_id;
          if (routeId && routeStops[routeId]) {
            routeStops[routeId].forEach(stopId => stopIdsToShow.add(stopId));
          }
        });
      }
      
      // Create features for each stop
      for (const stopId of stopIdsToShow) {
        const stop = allStops[stopId];
        if (stop) {
          features.push({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [stop.lon, stop.lat]
            },
            properties: {
              stop_id: stopId,
              stop_name: stop.name
            }
          });
        }
      }
      
      return { type: 'FeatureCollection', features };
    }

    // Linear interpolation between two coordinates
    function lerpCoordinates(from, to, t) {
      return [
        from[0] + (to[0] - from[0]) * t,
        from[1] + (to[1] - from[1]) * t
      ];
    }

    // Interpolate along a path (array of coordinates) based on progress t (0 to 1)
    function lerpAlongPath(path, t) {
      if (!path || path.length === 0) return null;
      if (path.length === 1) return path[0];
      
      // Calculate total path length
      let totalLength = 0;
      const segmentLengths = [];
      for (let i = 0; i < path.length - 1; i++) {
        const dist = haversineDistance(
          path[i][1], path[i][0],
          path[i + 1][1], path[i + 1][0]
        );
        segmentLengths.push(dist);
        totalLength += dist;
      }
      
      // Handle zero-length path
      if (totalLength === 0) return path[0];
      
      // Find which segment we should be on based on progress
      const targetDistance = t * totalLength;
      let accumulatedDistance = 0;
      
      for (let i = 0; i < segmentLengths.length; i++) {
        const segmentLength = segmentLengths[i];
        if (accumulatedDistance + segmentLength >= targetDistance) {
          // We're on this segment
          const segmentProgress = (targetDistance - accumulatedDistance) / segmentLength;
          return lerpCoordinates(path[i], path[i + 1], segmentProgress);
        }
        accumulatedDistance += segmentLength;
      }
      
      // If we somehow get here, return the last point
      return path[path.length - 1];
    }

    // Animation frame function
    function animatePositions(timestamp) {
      if (!animationStartTime) {
        animationStartTime = timestamp;
      }

      const elapsed = timestamp - animationStartTime;
      const progress = Math.min(elapsed / ANIMATION_DURATION_MS, 1);
      
      // Use easing function for smoother animation (ease-in-out)
      const eased = progress < 0.5
        ? 2 * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

      // Create interpolated GeoJSON - minimize object allocations
      const interpolatedFeatures = new Array(vehiclesGeoJSON.features.length);
      for (let i = 0; i < vehiclesGeoJSON.features.length; i++) {
        const feature = vehiclesGeoJSON.features[i];
        const vehicleId = feature.properties.id;
        if (vehicleId && previousPositions[vehicleId] && targetPositions[vehicleId]) {
          let interpolatedCoords;
          
          // Use path-based interpolation if available, otherwise use linear interpolation
          if (animationPaths[vehicleId] && animationPaths[vehicleId].length > 0) {
            interpolatedCoords = lerpAlongPath(animationPaths[vehicleId], eased);
          } else {
            interpolatedCoords = lerpCoordinates(
              previousPositions[vehicleId],
              targetPositions[vehicleId],
              eased
            );
          }
          
          // Create new feature with interpolated coordinates
          interpolatedFeatures[i] = {
            type: feature.type,
            id: feature.id,
            geometry: {
              type: feature.geometry.type,
              coordinates: interpolatedCoords
            },
            properties: feature.properties
          };
        } else {
          interpolatedFeatures[i] = feature;
        }
      }

      const interpolatedGeoJSON = {
        type: 'FeatureCollection',
        features: interpolatedFeatures
      };

      // Update map with interpolated positions
      const filteredVehicles = applyFilter(interpolatedGeoJSON);
      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
      }

      // Continue animation or finish
      if (progress < 1) {
        requestAnimationFrame(animatePositions);
      } else {
        animationInProgress = false;
        animationStartTime = null;
      }
    }

    // Start position animation
    function startPositionAnimation(newGeoJSON) {
      // Store previous positions
      if (vehiclesGeoJSON.features.length > 0) {
        vehiclesGeoJSON.features.forEach(feature => {
          const vehicleId = feature.properties.id;
          if (vehicleId) {
            previousPositions[vehicleId] = feature.geometry.coordinates;
          }
        });
      }

      // Store target positions from new data and calculate animation paths
      newGeoJSON.features.forEach(feature => {
        const vehicleId = feature.properties.id;
        if (vehicleId) {
          targetPositions[vehicleId] = feature.geometry.coordinates;
          
          // If this is a new vehicle, set previous position to current to avoid animation from 0,0
          if (!previousPositions[vehicleId]) {
            previousPositions[vehicleId] = feature.geometry.coordinates;
          }
          
          // Calculate animation path when snapToRoute is enabled
          if (snapToRoute && previousPositions[vehicleId]) {
            const prevCoords = previousPositions[vehicleId];
            const targetCoords = targetPositions[vehicleId];
            const tripId = feature.properties.trip_id;
            
            // Get shape for this vehicle's trip
            const shapeId = tripId ? tripToShape[tripId] : null;
            const shape = shapeId ? allShapes[shapeId] : null;
            const shapeCoords = shape ? shape.geometry.coordinates : null;
            
            if (shapeCoords && shapeCoords.length >= 2) {
              const SNAP_THRESHOLD_M = 100; // 100m threshold for snapping to route
              
              // Find nearest points on shape for both previous and target positions
              const prevNearest = findNearestPointOnShape(prevCoords, shapeCoords);
              const targetNearest = findNearestPointOnShape(targetCoords, shapeCoords);
              
              // Only use path-based animation if both points are close enough to the route
              if (prevNearest.distance <= SNAP_THRESHOLD_M && targetNearest.distance <= SNAP_THRESHOLD_M) {
                // Get the path along the shape
                const path = getPathAlongShape(
                  shapeCoords,
                  prevNearest.point,
                  prevNearest.segmentIndex,
                  targetNearest.point,
                  targetNearest.segmentIndex
                );
                
                if (path && path.length >= 2) {
                  // Use the calculated path for animation
                  animationPaths[vehicleId] = path;
                } else {
                  // Path calculation failed, clear any existing path
                  delete animationPaths[vehicleId];
                }
              } else {
                // One or both points are too far from route, don't use path-based animation
                delete animationPaths[vehicleId];
              }
            } else {
              // No shape data available
              delete animationPaths[vehicleId];
            }
          } else {
            // snapToRoute is disabled or no previous position
            delete animationPaths[vehicleId];
          }
        }
      });

      // Update vehiclesGeoJSON reference
      vehiclesGeoJSON = newGeoJSON;

      // Start animation if not already running
      if (!animationInProgress) {
        animationInProgress = true;
        animationStartTime = null;
        requestAnimationFrame(animatePositions);
      }
    }

    function formatInterval(seconds) {
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      if (secs === 0) return `${minutes}m`;
      return `${minutes}m ${secs}s`;
    }

    // Update trails and routes only (not vehicle positions - those are animated separately)
    function updateMapSourceNonAnimated() {
      const trailsGeoJSON = buildTrailsGeoJSON();

      // --- Filter shapes based on filter text ---
      let routeIds = new Set();
      if (cachedFilterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(cachedFilterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        const filteredVehicles = applyFilter(vehiclesGeoJSON);
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      
      // Only build shape features if routes are enabled
      const shapeFeatures = showRoutes ? (function() {
        const features = [];
        for (const rid of routeIds) {
          const sids = routeToShapes[rid];
          if (!sids) continue;
          for (const sid of sids) {
            if (allShapes[sid]) features.push(allShapes[sid]);
          }
        }
        return features;
      })() : [];

      // Build stops - only show when routes are enabled
      const stopsGeoJSON = showRoutes ? buildStopsGeoJSON() : {type:"FeatureCollection",features:[]};

      if (map.getSource('vehicle-trails')) {
        map.getSource('vehicle-trails').setData(trailsGeoJSON);
      }
      if (map.getSource('routes')) {
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
      }
      if (map.getSource('stops')) {
        map.getSource('stops').setData(stopsGeoJSON);
      }
    }

    function updateMapSource() {
      const filteredVehicles = applyFilter(vehiclesGeoJSON);
      const trailsGeoJSON = buildTrailsGeoJSON();

      // --- Filter shapes based on filter text ---
      let routeIds = new Set();
      if (cachedFilterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(cachedFilterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      
      // Only build shape features if routes are enabled
      const shapeFeatures = showRoutes ? (function() {
        const features = [];
        for (const rid of routeIds) {
          const sids = routeToShapes[rid];
          if (!sids) continue;
          for (const sid of sids) {
            if (allShapes[sid]) features.push(allShapes[sid]);
          }
        }
        return features;
      })() : [];

      // Build stops - only show when routes are enabled
      const stopsGeoJSON = showRoutes ? buildStopsGeoJSON() : {type:"FeatureCollection",features:[]};

      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
        map.getSource('vehicle-trails').setData(trailsGeoJSON);
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
        map.getSource('stops').setData(stopsGeoJSON);
      } else {
        map.addSource('vehicles', { 
          type: 'geojson', 
          data: filteredVehicles,
          generateId: false  // Use feature IDs from GeoJSON
        });
        map.addLayer({
          id: 'vehicle-icons',
          type: 'symbol',
          source: 'vehicles',
          layout: {
            'icon-image': [
              'case',
              ['==', ['get', 'route_type'], 0], 'tram-emoji',
              ['==', ['get', 'route_type'], 1], 'subway-emoji',
              ['==', ['get', 'route_type'], 2], 'rail-emoji',
              ['==', ['get', 'route_type'], 3], 'bus-emoji',
              ['==', ['get', 'route_type'], 4], 'ferry-emoji',
              ['==', ['get', 'route_type'], 5], 'cable-tram-emoji',
              ['==', ['get', 'route_type'], 6], 'aerial-lift-emoji',
              ['==', ['get', 'route_type'], 7], 'funicular-emoji',
              ['==', ['get', 'route_type'], 11], 'trolleybus-emoji',
              ['==', ['get', 'route_type'], 12], 'monorail-emoji',
              'bus-emoji'  // Default
            ],
            'icon-size': 0.3,
            'icon-allow-overlap': true,
            'icon-ignore-placement': true,
            'icon-rotation-alignment': 'map',
            'icon-rotate': ['coalesce', ['get', 'bearing'], 0]
          }
        });
        map.addLayer({
          id: 'vehicle-labels',
          type: 'symbol',
          source: 'vehicles',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ['get', 'route_id'], ''],
            'text-size': 12,
            'text-offset': [0, 1.2]
          }
        });
        map.on('click', 'vehicle-icons', (e) => {
          const vehicle = e.features[0];
          const props = vehicle.properties;
          
          // Set the route filter to the clicked vehicle's route
          if (props.route_id) {
            const routeNumber = props.route_id.split('-')[0];
            routeFilterEl.value = routeNumber;
            cachedFilterText = routeNumber.toLowerCase();
            updateClearButton();
            updateMapSource();
          }
          
          // Show popup with follow button
          showVehiclePopup(vehicle, e.lngLat);
        });
        map.on('mouseenter', 'vehicle-icons', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vehicle-icons', () => map.getCanvas().style.cursor = '');

        map.addSource('vehicle-trails', { type: 'geojson', data: trailsGeoJSON });
        map.addLayer({
          id: 'vehicle-trails-lines',
          type: 'line',
          source: 'vehicle-trails',
          paint: {
            'line-width': 2,
            'line-color': [
              'interpolate',
              ['linear'],
              ['get', 'speed'],
              0, '#888888',      // Stationary: grey
              5, '#F44336',      // Slow: red (5 m/s ‚âà 18 km/h)
              10, '#FF9800',     // Medium: orange (10 m/s ‚âà 36 km/h)
              15, '#FFC107',     // Fast: amber (15 m/s ‚âà 54 km/h)
              20, '#4CAF50'      // Very fast: green (20 m/s ‚âà 72 km/h)
            ],
            'line-opacity': 0.6
          }
        }, 'vehicle-icons'); // Add trails below vehicle icons
        map.getSource("routes").setData({type:"FeatureCollection",features:shapeFeatures});
        map.getSource("stops").setData(stopsGeoJSON);

        // Add click handler for stops
        map.on('click', 'stop-circles', (e) => {
          const props = e.features[0].properties;
          const stopId = props.stop_id;
          const stopName = props.stop_name;
          
          // Get upcoming arrivals
          const arrivals = getUpcomingArrivals(stopId);
          
          // Create popup HTML
          let html = `<div style="font-family: inherit; min-width: 200px; max-width: 280px; padding: 4px;">`;
          html += `<div style="font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #FF5722;">${stopName}</div>`;
          
          // Stop details
          html += `<div style="font-size: 13px; line-height: 1.6; color: #555;">`;
          html += `<div style="margin-bottom: 8px;"><span style="color: #888;">Stop ID:</span> <strong>${stopId}</strong></div>`;
          
          // Upcoming arrivals
          if (arrivals.length > 0) {
            html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
            html += `<div style="font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 6px;">Next arrivals (30min):</div>`;
            html += '<div style="font-size: 12px; color: #666; line-height: 1.8; max-height: 300px; overflow-y: auto;">';
            for (const arrival of arrivals) {
              const etaText = arrival.eta_minutes < 1 ? 'Now' : `${arrival.eta_minutes} min`;
              const routeLabel = arrival.vehicle_label || arrival.route_id;
              // Color scheme: Red (imminent) -> Yellow (medium) -> Green (comfortable)
              let etaColor;
              if (arrival.eta_minutes < 1) {
                etaColor = '#F44336'; // Red - arriving now
              } else if (arrival.eta_minutes <= 5) {
                etaColor = '#F44336'; // Red - arriving very soon (0-5 min)
              } else if (arrival.eta_minutes <= 10) {
                etaColor = '#FF9800'; // Orange - arriving soon (5-10 min)
              } else if (arrival.eta_minutes <= 15) {
                etaColor = '#FFC107'; // Amber - medium time (10-15 min)
              } else {
                etaColor = '#4CAF50'; // Green - comfortable time (15+ min)
              }
              html += `<div style="margin-bottom: 4px; padding: 4px; background: #f5f5f5; border-radius: 4px;">`;
              html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
              html += `<span style="font-weight: 600; color: #0077cc;">${routeLabel}</span>`;
              html += `<span style="color: ${etaColor}; font-weight: 600;">${etaText}</span>`;
              html += `</div>`;
              html += `<div style="font-size: 11px; color: #888; margin-top: 2px;">${arrival.stops_away} ${arrival.stops_away === 1 ? 'stop' : 'stops'} away</div>`;
              html += `</div>`;
            }
            html += '</div></div>';
          } else {
            html += `<div style="margin-top: 8px; padding: 8px; background: #f5f5f5; border-radius: 4px; color: #888; font-size: 12px; text-align: center;">No arrivals in next 30 minutes</div>`;
          }
          
          html += `</div></div>`;
          new maplibregl.Popup({
            maxWidth: '300px',
            className: 'custom-popup'
          }).setLngLat(e.lngLat).setHTML(html).addTo(map);
        });
        map.on('mouseenter', 'stop-circles', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'stop-circles', () => map.getCanvas().style.cursor = '');
      }
    }

    // Slideshow and follow mode functions
    function getRandomVehicle() {
      const filteredVehicles = applyFilter(vehiclesGeoJSON);
      const vehicles = filteredVehicles.features;
      if (vehicles.length === 0) return null;
      const randomIndex = Math.floor(Math.random() * vehicles.length);
      return vehicles[randomIndex];
    }

    function stopFollowMode() {
      followModeActive = false;
      currentFollowedVehicle = null;
      if (rotationAnimationId) {
        cancelAnimationFrame(rotationAnimationId);
        rotationAnimationId = null;
      }
      currentRotationAngle = 0;
      rotationStartTime = null;
      
      // Close popup if it exists
      if (currentFollowPopup) {
        currentFollowPopup.remove();
        currentFollowPopup = null;
      }
      
      // Hide follow indicator
      followIndicator.classList.remove('visible');
      
      // Reset camera to default view when stopping follow mode
      map.easeTo({
        pitch: 0,
        bearing: 0,
        duration: 1000
      });
    }

    function stopSlideshow() {
      slideshowActive = false;
      slideshowBtn.classList.remove('active');
      if (slideshowTimer) {
        clearTimeout(slideshowTimer);
        slideshowTimer = null;
      }
      stopFollowMode();
      logDebug('Slideshow stopped', 'info');
    }

    function followVehicle(vehicleId, coords, showPopup = false, autoAdvance = false) {
      stopFollowMode(); // Stop any existing follow mode
      
      currentFollowedVehicle = vehicleId;
      followModeActive = true;
      currentRotationAngle = 0;
      
      // Get vehicle info for display
      const vehicle = vehiclesGeoJSON.features.find(f => f.properties.id === vehicleId);
      const vehicleLabel = vehicle ? (vehicle.properties.label || vehicle.properties.route_id || 'Vehicle') : 'Vehicle';
      
      // Show follow indicator
      if (autoAdvance) {
        followIndicatorText.textContent = `üé¨ Slideshow: Following ${vehicleLabel}`;
      } else {
        followIndicatorText.textContent = `üìπ Following ${vehicleLabel}`;
      }
      followIndicator.classList.add('visible');
      
      // Fly to vehicle with animation
      map.flyTo({
        center: coords,
        zoom: FOLLOW_MODE_ZOOM, // Closer zoom for better detail
        pitch: FOLLOW_MODE_PITCH, // Isometric-like view
        bearing: FOLLOW_MODE_INITIAL_BEARING,
        duration: FOLLOW_MODE_FLY_DURATION_MS,
        essential: true
      });
      
      // Wait for flyTo to complete before starting rotation animation
      // This prevents the rotation from interrupting the flyTo animation
      setTimeout(() => {
        if (!followModeActive) return; // Check if mode was cancelled during flyTo
        
        // Don't show popup automatically - user can toggle it if needed
        
        // Start rotation animation using requestAnimationFrame for smooth rotation
        rotationStartTime = performance.now();
        let lastKnownCoords = null;
        
        function animateRotation(currentTime) {
          if (!followModeActive) {
            return;
          }
          
          // Calculate elapsed time since rotation started
          const elapsedSeconds = (currentTime - rotationStartTime) / MILLISECONDS_PER_SECOND;
          
          // Calculate current angle based on elapsed time and rotation speed
          currentRotationAngle = (ROTATION_SPEED * elapsedSeconds) % DEGREES_IN_CIRCLE;
          
          // Update camera bearing smoothly
          map.setBearing(currentRotationAngle);
          
          // Keep camera centered on vehicle (it may have moved)
          const vehicle = vehiclesGeoJSON.features.find(f => f.properties.id === vehicleId);
          if (vehicle) {
            const newCoords = vehicle.geometry.coordinates;
            
            // Only fly to new position if coordinates have changed
            if (!lastKnownCoords || 
                lastKnownCoords[0] !== newCoords[0] || 
                lastKnownCoords[1] !== newCoords[1]) {
              // Use flyTo with 2 second duration for smooth transitions
              map.flyTo({
                center: newCoords,
                duration: FOLLOW_MODE_FLY_DURATION_MS, // 2 seconds for smooth animation
                essential: false
              });
              lastKnownCoords = newCoords.slice(); // Store a copy
            }
            
            // Update popup position if it exists
            if (currentFollowPopup && currentFollowPopup.isOpen()) {
              currentFollowPopup.setLngLat(newCoords);
            }
          }
          
          // Continue animation loop
          rotationAnimationId = requestAnimationFrame(animateRotation);
        }
        
        // Start the animation loop
        rotationAnimationId = requestAnimationFrame(animateRotation);
      }, FOLLOW_MODE_FLY_DURATION_MS + FOLLOW_MODE_FLY_BUFFER_MS); // Wait for flyTo duration + small buffer
      
      // Set up auto-advance if in slideshow mode
      if (autoAdvance) {
        slideshowTimer = setTimeout(() => {
          if (slideshowActive) {
            startSlideshow(); // Move to next random vehicle
          }
        }, SLIDESHOW_DURATION_MS);
      }
    }

    function showVehiclePopup(vehicle, coords) {
      const props = vehicle.properties;
      const vehicleId = props.id;
      
      // Create popup HTML with follow button
      let html = `<div style="font-family: inherit; min-width: 200px; max-width: 280px; padding: 4px;">`;
      html += `<div style="font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #0077cc; word-wrap: break-word;">${props.label || props.route_id || 'Vehicle'}</div>`;
      
      // Vehicle details
      html += `<div style="font-size: 13px; line-height: 1.6; color: #555;">`;
      if (props.human_readable_id) {
        html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Human-readable ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.human_readable_id}</strong></div>`;
      }
      html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Trip ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.trip_id || '‚Äî'}</strong></div>`;
      html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Vehicle ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.id || '‚Äî'}</strong></div>`;
      
      // Last seen time
      if (props.timestamp) {
        const lastSeenTime = new Date(Number(props.timestamp) * 1000);
        const timeStr = lastSeenTime.toLocaleTimeString();
        html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Last seen:</span> <strong>${timeStr}</strong></div>`;
      }
      
      // Add current speed if available
      if (vehicleId && vehicleHistory[vehicleId] && vehicleHistory[vehicleId].length >= 2) {
        const history = vehicleHistory[vehicleId];
        const lastPos = history[history.length - 1];
        const prevPos = history[history.length - 2];
        const timeDiff = (lastPos.timestamp - prevPos.timestamp) / 1000;
        
        if (timeDiff > 0) {
          const distance = haversineDistance(
            prevPos.coords[1], prevPos.coords[0],
            lastPos.coords[1], lastPos.coords[0]
          );
          const speedMps = distance / timeDiff;
          const speedKmh = Math.round(speedMps * 3.6);
          html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Current speed:</span> <strong style="color: #0077cc;">${speedKmh} km/h</strong></div>`;
        }
      }
      html += `</div>`;
      
      // Add distance history if available
      if (vehicleId && vehicleHistory[vehicleId]) {
        const distances = calculateDistances(vehicleId);
        if (distances.length > 0) {
          html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
          html += `<div style="font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 6px;">Distance traveled:</div>`;
          html += '<div style="font-size: 12px; color: #666; line-height: 1.8;">';
          for (const d of distances) {
            const avgSpeed = d.speedKmh;
            const speedColor = avgSpeed > 40 ? '#4CAF50' : avgSpeed > 20 ? '#FFC107' : '#888';
            html += `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;">`;
            html += `<span>${formatInterval(d.interval)}:</span>`;
            html += `<span><strong>${d.distance}m</strong> <span style="color: ${speedColor};">(${d.speedKmh} km/h)</span></span>`;
            html += `</div>`;
          }
          html += '</div></div>';
        }
      }
      
      // Add follow button
      html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
      html += `<button id="followBtn" style="width: 100%; padding: 8px 12px; background: linear-gradient(to bottom, #0077cc, #0066b3); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; transition: background 0.2s;">üìπ Follow this vehicle</button>`;
      html += `</div>`;
      
      html += '</div>';
      
      const popup = new maplibregl.Popup({
        maxWidth: '300px',
        className: 'custom-popup'
      }).setLngLat(coords).setHTML(html).addTo(map);
      
      // Add event listener for follow button after popup is added to DOM
      setTimeout(() => {
        const followBtn = document.getElementById('followBtn');
        if (followBtn) {
          followBtn.addEventListener('click', () => {
            stopSlideshow(); // Stop slideshow if active
            popup.remove(); // Close popup
            followVehicle(vehicleId, coords, false, false);
            logDebug(`Started follow mode for vehicle ${vehicleId}`, 'info');
          });
          
          // Add hover effect
          followBtn.addEventListener('mouseenter', () => {
            followBtn.style.background = 'linear-gradient(to bottom, #0066b3, #00558a)';
          });
          followBtn.addEventListener('mouseleave', () => {
            followBtn.style.background = 'linear-gradient(to bottom, #0077cc, #0066b3)';
          });
        }
      }, 100);
      
      return popup;
    }

    function startSlideshow() {
      const vehicle = getRandomVehicle();
      if (!vehicle) {
        logDebug('No vehicles available for slideshow', 'warn');
        stopSlideshow();
        return;
      }
      
      const vehicleId = vehicle.properties.id;
      const coords = vehicle.geometry.coordinates;
      
      logDebug(`Slideshow: Following vehicle ${vehicleId} (${vehicle.properties.label || vehicle.properties.route_id})`, 'info');
      followVehicle(vehicleId, coords, false, true);
    }

    refreshBtn.addEventListener('click', () => fetchFeedAndUpdate());
    
    // Show/hide clear button based on input value
    function updateClearButton() {
      if (routeFilterEl.value.trim()) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }
    }
    
    routeFilterEl.addEventListener('input', () => {
      updateClearButton();
      cachedFilterText = routeFilterEl.value.trim().toLowerCase();
      updateMapSource();
    });
    
    clearBtn.addEventListener('click', () => {
      routeFilterEl.value = '';
      cachedFilterText = '';
      updateClearButton();
      updateMapSource();
      routeFilterEl.focus();
    });
    
    autoRefreshBtn.addEventListener('click', () => { 
      autoRefreshBtn.classList.toggle('active');
      if (autoRefreshBtn.classList.contains('active')) {
        startAutoRefresh();
      } else {
        stopAutoRefresh();
      }
    });
    locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) return alert('Geolocation not available');
      navigator.geolocation.getCurrentPosition(pos => {
        const coords = [pos.coords.longitude, pos.coords.latitude];
        userLocation.features = [{
          type: 'Feature',
          geometry: { type: 'Point', coordinates: coords }
        }];
        map.getSource('user-location').setData(userLocation);
        map.flyTo({ center: coords, zoom: 14 });
      }, e => alert('Unable to get location: ' + e.message));
    });
    
    toggleRoutesBtn.addEventListener('click', () => {
      toggleRoutesBtn.classList.toggle('active');
      showRoutes = toggleRoutesBtn.classList.contains('active');
      updateMapSource();
    });
    
    snapToRouteBtn.addEventListener('click', () => {
      snapToRouteBtn.classList.toggle('active');
      snapToRoute = snapToRouteBtn.classList.contains('active');
      updateMapSource();
      logDebug(`Route snapping ${snapToRoute ? 'enabled' : 'disabled'}`, 'info');
    });
    
    slideshowBtn.addEventListener('click', () => {
      slideshowBtn.classList.toggle('active');
      if (slideshowBtn.classList.contains('active')) {
        slideshowActive = true;
        logDebug('Slideshow started', 'info');
        startSlideshow();
      } else {
        stopSlideshow();
      }
    });
    
    // Add event listener for follow indicator close button
    const followIndicatorClose = document.getElementById('followIndicatorClose');
    if (followIndicatorClose) {
      followIndicatorClose.addEventListener('click', () => {
        stopSlideshow();
        logDebug('Follow/slideshow mode stopped via close button', 'info');
      });
    }
    
    // Add keyboard support for exiting follow/slideshow mode and clearing filter
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (followModeActive || slideshowActive) {
          stopSlideshow();
          logDebug('Follow/slideshow mode stopped via Escape key', 'info');
        } else if (routeFilterEl.value.trim()) {
          // Clear the route filter
          routeFilterEl.value = '';
          cachedFilterText = '';
          updateClearButton();
          updateMapSource();
          logDebug('Route filter cleared via Escape key', 'info');
        }
      }
    });
    
    // Allow clicking on map background to exit follow mode (but not slideshow) and clear filter
    map.on('click', (e) => {
      // Only exit follow mode if clicking on empty space (not on a vehicle or stop)
      const features = map.queryRenderedFeatures(e.point, {
        layers: ['vehicle-icons', 'stop-circles']
      });
      
      if (features.length === 0) {
        if (followModeActive && !slideshowActive) {
          stopFollowMode();
          logDebug('Follow mode stopped via map click', 'info');
        } else if (routeFilterEl.value.trim()) {
          // Clear the route filter
          routeFilterEl.value = '';
          cachedFilterText = '';
          updateClearButton();
          updateMapSource();
          logDebug('Route filter cleared via map click', 'info');
        }
      }
    });

    function startAutoRefresh() {
      stopAutoRefresh();
      autoTimer = setInterval(fetchFeedAndUpdate, REFRESH_INTERVAL_MS);
    }
    function stopAutoRefresh() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }

    (async function(){
      try {
        updateStatus('Loading protocol definitions...');
        await loadProto();
        updateStatus('Waiting for map to load...');
        
        // Handle map initialization (may already be loaded or still loading)
        const initializeApp = async () => {
          try {
            logDebug('Map loaded successfully', 'info');
            loadEmojiImages(); // Load emoji icons
            await loadGTFS();
            updateStatus('Fetching initial vehicle data...');
            await fetchFeedAndUpdate();
            updateStatus('Starting auto-refresh...');
            startAutoRefresh();
            logDebug('Application initialized successfully', 'info');
            updateStatus('Ready! All systems operational.');
            // Unlock UI after successful initialization
            unlockUI();
            // Hide status bar after 2 seconds
            setTimeout(() => {
              hideStatusBar();
            }, 2000);
          } catch (err) {
            logDebug('Error during map initialization: ' + err.message, 'error');
            updateStatus('Error during initialization');
            // Unlock UI even on error so user can try to refresh
            unlockUI();
            alert('Failed to load map data: ' + err.message);
          }
        };
        
        // Check if map is already loaded or wait for it
        if (map.loaded()) {
          logDebug('Map already loaded, initializing immediately', 'info');
          await initializeApp();
        } else {
          map.on('load', initializeApp);
        }
      } catch (err) {
        logDebug('Startup error: ' + err.message, 'error');
        updateStatus('Startup error');
        // Unlock UI even on error so user can try to refresh
        unlockUI();
        alert('Failed to initialise: ' + err.message);
      }
    })();
  </script>
</body>
</html>
