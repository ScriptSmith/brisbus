<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="description" content="Live Brisbane bus tracking map using GTFS real-time data" />
  <meta name="theme-color" content="#0077cc" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Brisbane Buses" />
  <title>Brisbane Buses — Live Map (GTFS)</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .ui { 
      position: absolute; 
      left: 12px; 
      top: 12px; 
      right: 12px;
      z-index: 2; 
      background: rgba(255,255,255,0.95); 
      padding: 12px; 
      border-radius: 8px; 
      box-shadow: 0 6px 18px rgba(0,0,0,0.12); 
      max-width: 400px;
    }
    .ui h1 { margin: 0 0 8px 0; font-size: 16px; }
    .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .controls input[type=text] { flex: 1; min-width: 150px; padding: 8px 10px; border-radius: 6px; border: 1px solid #ddd; font-size: 14px; }
    button { 
      padding: 8px 12px; 
      border-radius: 6px; 
      border: 1px solid #ccc; 
      background: #f6f6f6; 
      cursor: pointer; 
      font-size: 14px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    button:active { background: #e6e6e6; }
    .meta { margin-top: 8px; font-size: 13px; color: #444; }
    .legend { margin-top: 8px; font-size: 12px; color: #666; line-height: 1.4; }
    
    /* Mobile responsive styles */
    @media (max-width: 640px) {
      .ui {
        left: 8px;
        right: 8px;
        top: 8px;
        padding: 10px;
        max-width: none;
      }
      .ui h1 { font-size: 15px; }
      .controls { gap: 6px; }
      .controls input[type=text] { 
        padding: 10px 8px;
        font-size: 16px; /* Prevent zoom on iOS */
      }
      button { 
        padding: 10px; 
        font-size: 14px;
        white-space: nowrap;
      }
      .meta { font-size: 12px; }
      .legend { font-size: 11px; }
    }
    
    @media (max-width: 400px) {
      .ui {
        left: 6px;
        right: 6px;
        top: 6px;
        padding: 8px;
      }
      .controls { gap: 4px; }
      .controls input[type=text] { min-width: 120px; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="ui">
    <h1>Brisbane buses — Live</h1>
    <div class="controls">
      <input id="routeFilter" placeholder="Filter by route number (optional)" />
      <button id="refreshBtn">Refresh</button>
    </div>
    <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
      <label><input id="autoRefresh" type="checkbox" checked /> Auto (10s)</label>
      <button id="locateBtn">My location</button>
    </div>
    <div class="meta">
      <div>Last update: <span id="lastUpdate">—</span></div>
      <div>Vehicles shown: <span id="count">0</span></div>
    </div>
    <div class="legend">Source: Translink GTFS &amp; GTFS-RT (proxied) — vector tiles: Carto basemap</div>
  </div>

  <script src="https://unpkg.com/protobufjs@7.2.3/dist/protobuf.min.js"></script>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script>
    const PROXY_FEED_URL = 'https://api.codetabs.com/v1/proxy?quest=https://gtfsrt.api.translink.com.au/api/realtime/SEQ/VehiclePositions';
    // Support both GitHub Pages (/brisbus/) and local dev
    const GTFS_BASE_URL = window.location.pathname.includes('/brisbus/') ? '/brisbus/data/' : '/data/';
    const PROTO_URL = 'https://raw.githubusercontent.com/google/transit/master/gtfs-realtime/proto/gtfs-realtime.proto';
    const REFRESH_INTERVAL_MS = 10000;
    const HISTORY_WINDOW_MS = 10 * 60 * 1000; // 10 minutes for trails

    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [153.0251, -27.4679],
      zoom: 11
    });
    map.addControl(new maplibregl.NavigationControl({showCompass: false}), 'top-right');

    let root = null, feedMessageType = null;
    let vehiclesGeoJSON = { type: 'FeatureCollection', features: [] };
    let vehicleHistory = {}; // vehicle_id → array of {coords, timestamp, speed}
    let allShapes = {};      // shape_id → Feature
    let routeToShapes = {};  // route_id → Set(shape_id)
    let autoTimer = null;
    let userLocation = { type: 'FeatureCollection', features: [] };

    const lastUpdateEl = document.getElementById('lastUpdate');
    const countEl = document.getElementById('count');
    const refreshBtn = document.getElementById('refreshBtn');
    const autoRefreshEl = document.getElementById('autoRefresh');
    const routeFilterEl = document.getElementById('routeFilter');
    const locateBtn = document.getElementById('locateBtn');

    async function loadProto() {
      const res = await fetch(PROTO_URL);
      const protoText = await res.text();
      const parsed = protobuf.parse(protoText);
      root = parsed.root;
      feedMessageType = root.lookupType('transit_realtime.FeedMessage');
    }

    /**
     * Fetch and decompress a GTFS file using gzip
     * Uses DecompressionStream API (supported in all modern browsers)
     */
    async function fetchAndDecompress(filename) {
      // Fetch and decompress gzip file
      console.log(`Fetching ${filename}.gz...`);
      const res = await fetch(`${GTFS_BASE_URL}${filename}.gz`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      
      // Use DecompressionStream to decompress gzip data
      const ds = new DecompressionStream('gzip');
      const decompressedStream = res.body.pipeThrough(ds);
      const decompressed = await new Response(decompressedStream).arrayBuffer();
      const text = new TextDecoder().decode(decompressed);
      
      console.log(`Successfully loaded and decompressed ${filename}.gz`);
      
      return text;
    }

    async function loadGTFS() {
      console.log('Loading GTFS data...');
      
      // Fetch compressed files
      const shapesTxt = await fetchAndDecompress('shapes.txt');
      const tripsTxt = await fetchAndDecompress('trips.txt');

      // --- Parse shapes.txt ---
      const lines = shapesTxt.trim().split(/\r?\n/);
      const headers = lines.shift().split(",");
      const idx = Object.fromEntries(headers.map((h,i)=>[h,i]));
      const tmp = {};
      for (const line of lines) {
        const parts = line.split(",");
        const sid = parts[idx["shape_id"]];
        const lat = parseFloat(parts[idx["shape_pt_lat"]]);
        const lon = parseFloat(parts[idx["shape_pt_lon"]]);
        const seq = parseInt(parts[idx["shape_pt_sequence"]],10);
        if (!tmp[sid]) tmp[sid] = [];
        tmp[sid].push({seq, coord:[lon,lat]});
      }
      for (const sid in tmp) {
        tmp[sid].sort((a,b)=>a.seq-b.seq);
        allShapes[sid] = {
          type:"Feature",
          geometry:{type:"LineString", coordinates:tmp[sid].map(p=>p.coord)},
          properties:{shape_id:sid}
        };
      }

      // --- Parse trips.txt (route_id -> shape_id) ---
      const tlines = tripsTxt.trim().split(/\r?\n/);
      const theaders = tlines.shift().split(",");
      const tidx = Object.fromEntries(theaders.map((h,i)=>[h,i]));
      for (const line of tlines) {
        const parts = line.split(",");
        const rid = parts[tidx["route_id"]];
        const sid = parts[tidx["shape_id"]];
        if (!rid || !sid) continue;
        if (!routeToShapes[rid]) routeToShapes[rid] = new Set();
        routeToShapes[rid].add(sid);
      }

      // Initialise empty layer
      map.addSource("routes",{type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"route-lines",
        type:"line",
        source:"routes",
        paint:{
          "line-color":"#0077cc",
          "line-width":2,
          "line-opacity":0.6
        }
      });

      // Initialise user location layer
      map.addSource("user-location", { type: "geojson", data: userLocation });
      map.addLayer({
        id:"user-location-circle",
        type:"circle",
        source:"user-location",
        paint:{
          "circle-radius":10,
          "circle-color":"#0066ff",
          "circle-stroke-width":2,
          "circle-stroke-color":"#fff"
        }
      });
    }

    async function fetchFeedAndUpdate() {
      try {
        const res = await fetch(PROXY_FEED_URL, {cache: 'no-store'});
        if (!res.ok) throw new Error('Network response not ok: ' + res.status);
        const buffer = await res.arrayBuffer();
        const uint8 = new Uint8Array(buffer);
        const message = feedMessageType.decode(uint8);
        const object = feedMessageType.toObject(message, { longs: String, enums: String, bytes: String });
        const geojson = feedToGeoJSON(object);
        updateHistory(geojson);
        vehiclesGeoJSON = geojson;
        updateMapSource();
        lastUpdateEl.textContent = new Date().toLocaleString();
        countEl.textContent = geojson.features.length;
      } catch (err) {
        console.error(err);
        lastUpdateEl.textContent = 'Error fetching feed';
      }
    }

    function feedToGeoJSON(feedObj) {
      const feats = [];
      if (!feedObj || !feedObj.entity) return { type: 'FeatureCollection', features: [] };
      for (const e of feedObj.entity) {
        if (!e.vehicle) continue;
        const vp = e.vehicle.position;
        if (!vp || vp.latitude == null || vp.longitude == null) continue;
        const props = {
          id: e.id || (e.vehicle.vehicle && e.vehicle.vehicle.id) || null,
          label: (e.vehicle.vehicle && `${e.vehicle.trip.routeId.split("-")[0]}: ${e.vehicle.vehicle.label}`) || null,
          route_id: e.vehicle.trip && e.vehicle.trip.routeId || null,
          trip_id: e.vehicle.trip && e.vehicle.trip.tripId || null,
          bearing: vp.bearing || null,
          speed: vp.speed || null,
          current_stop_sequence: e.vehicle.currentStopSequence || null,
          timestamp: e.vehicle.timestamp || null
        };
        feats.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [vp.longitude, vp.latitude] },
          properties: props
        });
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function updateHistory(currentGeoJSON) {
      const now = Date.now();
      for (const f of currentGeoJSON.features) {
        if (f.properties.timestamp && f.properties.id) {
          const vehicleId = f.properties.id;
          const tsMs = Number(f.properties.timestamp) * 1000;
          
          if (!vehicleHistory[vehicleId]) {
            vehicleHistory[vehicleId] = [];
          }
          
          // Add new position if it's not a duplicate
          const history = vehicleHistory[vehicleId];
          const isDuplicate = history.length > 0 && 
            history[history.length - 1].timestamp === tsMs;
          
          if (!isDuplicate) {
            history.push({
              coords: f.geometry.coordinates,
              timestamp: tsMs,
              speed: f.properties.speed || 0,
              route_id: f.properties.route_id,
              label: f.properties.label
            });
          }
        }
      }
      
      // Clean up old positions and empty vehicles
      for (const vehicleId in vehicleHistory) {
        vehicleHistory[vehicleId] = vehicleHistory[vehicleId].filter(
          pos => now - pos.timestamp <= HISTORY_WINDOW_MS
        );
        if (vehicleHistory[vehicleId].length === 0) {
          delete vehicleHistory[vehicleId];
        }
      }
    }

    function applyFilter(geojson) {
      const filterText = routeFilterEl.value.trim().toLowerCase();
      if (!filterText) return geojson;
      return {
        type: 'FeatureCollection',
        features: geojson.features.filter(f => {
          return (f.properties.route_id && f.properties.route_id.toLowerCase().includes(filterText)) ||
                 (f.properties.label && f.properties.label.toLowerCase().includes(filterText));
        })
      };
    }

    function buildTrailsGeoJSON() {
      const features = [];
      const filterText = routeFilterEl.value.trim().toLowerCase();
      
      for (const vehicleId in vehicleHistory) {
        const history = vehicleHistory[vehicleId];
        if (history.length < 2) continue; // Need at least 2 points for a line
        
        // Apply filter
        if (filterText) {
          const lastPos = history[history.length - 1];
          const matchesFilter = 
            (lastPos.route_id && lastPos.route_id.toLowerCase().includes(filterText)) ||
            (lastPos.label && lastPos.label.toLowerCase().includes(filterText));
          if (!matchesFilter) continue;
        }
        
        // Calculate average speed for the trail
        // First try to use reported speeds if available
        const speeds = history.map(h => h.speed || 0).filter(s => s > 0);
        let avgSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
        
        // If no reported speeds, calculate from position changes
        if (avgSpeed === 0 && history.length >= 2) {
          let totalDistance = 0;
          let totalTime = 0;
          
          for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            const timeDiff = (curr.timestamp - prev.timestamp) / 1000; // seconds
            
            if (timeDiff > 0) {
              const dist = haversineDistance(
                prev.coords[1], prev.coords[0],
                curr.coords[1], curr.coords[0]
              );
              totalDistance += dist;
              totalTime += timeDiff;
            }
          }
          
          if (totalTime > 0) {
            avgSpeed = totalDistance / totalTime; // meters per second
          }
        }
        
        features.push({
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: history.map(h => h.coords)
          },
          properties: {
            vehicle_id: vehicleId,
            speed: avgSpeed
          }
        });
      }
      
      return { type: 'FeatureCollection', features };
    }

    function calculateDistances(vehicleId) {
      const history = vehicleHistory[vehicleId];
      if (!history || history.length < 2) return [];
      
      const now = Date.now();
      const distances = [];
      const intervals = [10, 20, 30, 60, 120, 180, 300, 600]; // seconds
      
      for (const interval of intervals) {
        const targetTime = now - (interval * 1000);
        
        // Find the closest position in history to this time
        let closestPos = null;
        let minDiff = Infinity;
        
        for (const pos of history) {
          const diff = Math.abs(pos.timestamp - targetTime);
          if (diff < minDiff) {
            minDiff = diff;
            closestPos = pos;
          }
        }
        
        // Calculate distance if we found a position
        if (closestPos && minDiff < interval * 500) { // within half the interval
          const currentPos = history[history.length - 1];
          const distance = haversineDistance(
            closestPos.coords[1], closestPos.coords[0],
            currentPos.coords[1], currentPos.coords[0]
          );
          
          if (distance > 0) {
            const actualTimeDiff = (currentPos.timestamp - closestPos.timestamp) / 1000; // seconds
            const speedMps = actualTimeDiff > 0 ? distance / actualTimeDiff : 0; // m/s
            const speedKmh = Math.round(speedMps * 3.6); // convert to km/h
            distances.push({ 
              interval, 
              distance: Math.round(distance),
              speedKmh 
            });
          }
        }
      }
      
      return distances;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function formatInterval(seconds) {
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      if (secs === 0) return `${minutes}m`;
      return `${minutes}m ${secs}s`;
    }

    function updateMapSource() {
      const filteredVehicles = applyFilter(vehiclesGeoJSON);
      const trailsGeoJSON = buildTrailsGeoJSON();

      // --- Filter shapes based on filter text ---
      const filterText = routeFilterEl.value.trim().toLowerCase();
      let routeIds = new Set();
      if (filterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(filterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      const shapeFeatures = [];
      for (const rid of routeIds) {
        const sids = routeToShapes[rid];
        if (!sids) continue;
        for (const sid of sids) {
          if (allShapes[sid]) shapeFeatures.push(allShapes[sid]);
        }
      }

      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
        map.getSource('vehicle-trails').setData(trailsGeoJSON);
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
      } else {
        map.addSource('vehicles', { type: 'geojson', data: filteredVehicles });
        map.addLayer({
          id: 'vehicle-circles',
          type: 'circle',
          source: 'vehicles',
          paint: { 'circle-radius': 6, 'circle-stroke-width': 1, 'circle-stroke-color': '#fff' }
        });
        map.addLayer({
          id: 'vehicle-labels',
          type: 'symbol',
          source: 'vehicles',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ['get', 'route_id'], ''],
            'text-size': 12,
            'text-offset': [0, 1.3]
          }
        });
        map.on('click', 'vehicle-circles', (e) => {
          const props = e.features[0].properties;
          const vehicleId = props.id;
          
          let html = `<div style="min-width:150px"><strong>${props.label || props.route_id || 'Vehicle'}</strong><br/>Trip: ${props.trip_id || '-'}<br/>ID: ${props.id || '-'}<br/>Last seen: ${props.timestamp ? new Date(Number(props.timestamp) * 1000).toLocaleTimeString() : '-'}`;
          
          // Add current speed if available
          if (vehicleId && vehicleHistory[vehicleId] && vehicleHistory[vehicleId].length >= 2) {
            const history = vehicleHistory[vehicleId];
            // Calculate current speed from last two positions
            const lastPos = history[history.length - 1];
            const prevPos = history[history.length - 2];
            const timeDiff = (lastPos.timestamp - prevPos.timestamp) / 1000; // seconds
            
            if (timeDiff > 0) {
              const distance = haversineDistance(
                prevPos.coords[1], prevPos.coords[0],
                lastPos.coords[1], lastPos.coords[0]
              );
              const speedMps = distance / timeDiff;
              const speedKmh = Math.round(speedMps * 3.6);
              html += `<br/>Speed: ${speedKmh} km/h`;
            }
          }
          
          // Add distance history if available
          if (vehicleId && vehicleHistory[vehicleId]) {
            const distances = calculateDistances(vehicleId);
            if (distances.length > 0) {
              html += '<br/><br/><strong>Distance traveled:</strong><br/>';
              html += '<ul style="margin:4px 0;padding-left:20px;font-size:12px;">';
              for (const d of distances) {
                html += `<li>${formatInterval(d.interval)}: ${d.distance}m (${d.speedKmh} km/h)</li>`;
              }
              html += '</ul>';
            }
          }
          
          html += '</div>';
          new maplibregl.Popup().setLngLat(e.lngLat).setHTML(html).addTo(map);
        });
        map.on('mouseenter', 'vehicle-circles', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vehicle-circles', () => map.getCanvas().style.cursor = '');

        map.addSource('vehicle-trails', { type: 'geojson', data: trailsGeoJSON });
        map.addLayer({
          id: 'vehicle-trails-lines',
          type: 'line',
          source: 'vehicle-trails',
          paint: {
            'line-width': 2,
            'line-color': [
              'interpolate',
              ['linear'],
              ['get', 'speed'],
              0, '#888888',      // Stationary: grey
              5, '#4CAF50',      // Slow: green (5 m/s ≈ 18 km/h)
              10, '#FFC107',     // Medium: amber (10 m/s ≈ 36 km/h)
              15, '#FF9800',     // Fast: orange (15 m/s ≈ 54 km/h)
              20, '#F44336'      // Very fast: red (20 m/s ≈ 72 km/h)
            ],
            'line-opacity': 0.6
          }
        }, 'vehicle-circles'); // Add trails below vehicle circles
        map.getSource("routes").setData({type:"FeatureCollection",features:shapeFeatures});
      }
    }

    refreshBtn.addEventListener('click', () => fetchFeedAndUpdate());
    routeFilterEl.addEventListener('input', () => updateMapSource());
    autoRefreshEl.addEventListener('change', () => { if (autoRefreshEl.checked) startAutoRefresh(); else stopAutoRefresh(); });
    locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) return alert('Geolocation not available');
      navigator.geolocation.getCurrentPosition(pos => {
        const coords = [pos.coords.longitude, pos.coords.latitude];
        userLocation.features = [{
          type: 'Feature',
          geometry: { type: 'Point', coordinates: coords }
        }];
        map.getSource('user-location').setData(userLocation);
        map.flyTo({ center: coords, zoom: 14 });
      }, e => alert('Unable to get location: ' + e.message));
    });

    function startAutoRefresh() {
      stopAutoRefresh();
      autoTimer = setInterval(fetchFeedAndUpdate, REFRESH_INTERVAL_MS);
    }
    function stopAutoRefresh() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }

    (async function(){
      try {
        await loadProto();
        map.on('load', async () => {
          await loadGTFS();
          fetchFeedAndUpdate();
          startAutoRefresh();
        });
      } catch (err) {
        console.error('Startup error', err);
        alert('Failed to initialise: ' + err.message);
      }
    })();
  </script>
</body>
</html>
