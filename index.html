<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="description" content="Live Brisbane bus tracking map using GTFS real-time data" />
  <meta name="theme-color" content="#0077cc" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Brisbane Buses" />
  <title>Brisbane Buses — Live Map (GTFS)</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    
    .ui { 
      position: absolute; 
      left: 12px; 
      top: 12px; 
      right: 12px;
      z-index: 2; 
      background: rgba(255,255,255,0.97); 
      padding: 14px 16px; 
      border-radius: 12px; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
      max-width: 420px;
      backdrop-filter: blur(10px);
    }
    
    .ui h1 { 
      margin: 0 0 12px 0; 
      font-size: 18px; 
      font-weight: 600;
      color: #1a1a1a;
      letter-spacing: -0.01em;
    }
    
    .controls { 
      display: flex; 
      gap: 10px; 
      align-items: stretch; 
      flex-wrap: wrap; 
    }
    
    .controls input[type=text] { 
      flex: 1; 
      min-width: 180px; 
      padding: 11px 14px; 
      border-radius: 8px; 
      border: 1.5px solid #ddd; 
      font-size: 15px;
      background: #fff;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    
    .controls input[type=text]:focus { 
      outline: none;
      border-color: #0077cc;
      box-shadow: 0 0 0 3px rgba(0, 119, 204, 0.1);
    }
    
    button { 
      padding: 11px 18px; 
      border-radius: 8px; 
      border: 1.5px solid #d0d0d0; 
      background: linear-gradient(to bottom, #fff, #f8f8f8); 
      cursor: pointer; 
      font-size: 15px;
      font-weight: 500;
      color: #333;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.15s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      white-space: nowrap;
    }
    
    button:hover { 
      background: linear-gradient(to bottom, #f8f8f8, #f0f0f0);
      border-color: #b8b8b8;
      box-shadow: 0 2px 4px rgba(0,0,0,0.12);
    }
    
    button:active { 
      background: #e8e8e8;
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }
    
    .toggle-btn.active {
      background: linear-gradient(to bottom, #0077cc, #0066b3);
      border-color: #0055aa;
      color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    
    .toggle-btn.active:hover {
      background: linear-gradient(to bottom, #0066b3, #005599);
      border-color: #004488;
    }
    
    .controls-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .controls-row label {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      cursor: pointer;
      user-select: none;
      font-size: 15px;
      color: #333;
      padding: 4px 0;
    }
    
    .controls-row input[type=checkbox] {
      cursor: pointer;
      width: 18px;
      height: 18px;
      margin: 0;
    }
    
    .meta { 
      margin-top: 12px; 
      padding-top: 12px;
      border-top: 1px solid #e8e8e8;
      font-size: 14px; 
      color: #555;
      line-height: 1.6;
    }
    
    .meta div {
      margin-bottom: 4px;
    }
    
    .meta span {
      font-weight: 500;
      color: #1a1a1a;
    }
    
    .legend { 
      margin-top: 10px; 
      padding-top: 10px;
      border-top: 1px solid #e8e8e8;
      font-size: 12px; 
      color: #777; 
      line-height: 1.5; 
    }
    
    /* Custom popup styling */
    .maplibregl-popup-content {
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      padding: 12px 14px;
    }
    
    .maplibregl-popup-close-button {
      font-size: 20px;
      padding: 4px 8px;
      color: #888;
    }
    
    .maplibregl-popup-close-button:hover {
      background: #f0f0f0;
      color: #333;
    }
    
    /* Mobile responsive styles */
    @media (max-width: 768px) {
      .ui {
        left: 10px;
        right: 10px;
        top: 10px;
        padding: 10px;
        max-width: none;
      }
      
      .ui h1 {
        font-size: 16px;
        margin-bottom: 8px;
      }
      
      /* Combine all controls into a single row */
      .controls,
      .controls-row {
        display: inline-flex;
        gap: 6px;
        flex-wrap: nowrap;
        margin-top: 0;
      }
      
      .controls input[type=text] {
        flex: 1;
        min-width: 0;
        padding: 10px;
        font-size: 16px; /* Prevent zoom on iOS */
      }
      
      button {
        padding: 10px 12px;
        font-size: 14px;
        white-space: nowrap;
      }
      
      .controls-row label {
        font-size: 14px;
        white-space: nowrap;
      }
      
      .meta {
        margin-top: 8px;
        padding-top: 8px;
        font-size: 13px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      
      .meta div {
        margin-bottom: 0;
        white-space: nowrap;
      }
      
      .legend {
        display: none; /* Hide on mobile */
      }
    }
    
    @media (max-width: 640px) {
      .ui {
        padding: 8px;
      }
      
      .ui h1 { 
        font-size: 15px; 
        margin-bottom: 6px;
      }
      
      .controls,
      .controls-row { 
        gap: 4px;
        flex-wrap: nowrap;
        margin-top: 0;
      }
      
      .controls input[type=text] { 
        padding: 9px 8px;
      }
      
      button { 
        padding: 9px 10px; 
        font-size: 13px;
      }
      
      .meta { 
        font-size: 12px; 
        margin-top: 6px;
        padding-top: 6px;
      }
    }
    
    @media (max-width: 400px) {
      .ui {
        left: 8px;
        right: 8px;
        top: 8px;
        padding: 6px;
      }
      
      .ui h1 {
        font-size: 14px;
        margin-bottom: 4px;
      }
      
      .controls,
      .controls-row { 
        gap: 3px;
        flex-wrap: nowrap;
        margin-top: 0;
      }
      
      .controls input[type=text] { 
        padding: 8px 6px;
        font-size: 16px;
      }
      
      button {
        padding: 8px 8px;
        font-size: 12px;
      }
      
      .controls-row label {
        font-size: 12px;
      }
      
      .meta {
        font-size: 11px;
        margin-top: 4px;
        padding-top: 4px;
      }
    }
    
    /* Status bar */
    #statusBar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 119, 204, 0.95);
      color: white;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      z-index: 1000;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.15);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    #statusBar.hidden {
      transform: translateY(100%);
      opacity: 0;
    }
    
    /* Debug toggle icon */
    #debugToggle {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.9);
      border: 1.5px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      z-index: 999;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: all 0.2s ease;
      user-select: none;
    }
    
    #debugToggle:hover {
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 3px 12px rgba(0,0,0,0.2);
      transform: scale(1.05);
    }
    
    #debugToggle.active {
      background: rgba(0, 119, 204, 0.95);
      color: white;
      border-color: #0055aa;
    }
    
    /* Debug pane */
    #debugPane {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40vh;
      background: rgba(30, 30, 30, 0.97);
      color: #e0e0e0;
      z-index: 998;
      display: flex;
      flex-direction: column;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    
    #debugPane.visible {
      transform: translateY(0);
    }
    
    #debugPane .debug-header {
      padding: 10px 16px;
      background: rgba(0, 119, 204, 0.9);
      color: white;
      font-weight: 600;
      font-size: 14px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #debugPane .debug-controls {
      display: flex;
      gap: 8px;
    }
    
    #debugPane .debug-controls button {
      padding: 4px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }
    
    #debugPane .debug-controls button:hover {
      background: rgba(255,255,255,0.3);
    }
    
    #debugPane .debug-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px 16px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
      font-size: 12px;
      line-height: 1.6;
    }
    
    #debugPane .log-entry {
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      border-left: 3px solid #888;
    }
    
    #debugPane .log-entry.info {
      border-left-color: #4CAF50;
    }
    
    #debugPane .log-entry.error {
      border-left-color: #F44336;
      background: rgba(244, 67, 54, 0.1);
    }
    
    #debugPane .log-entry.warn {
      border-left-color: #FFC107;
    }
    
    #debugPane .log-entry .timestamp {
      color: #888;
      font-size: 11px;
      margin-right: 8px;
    }
    
    #debugPane .log-entry .message {
      color: #e0e0e0;
    }
    
    #debugPane .log-entry.error .message {
      color: #ffcdd2;
    }
    
    @media (max-width: 768px) {
      #debugPane {
        height: 50vh;
      }
      
      #debugToggle {
        width: 28px;
        height: 28px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="ui">
    <h1>Brisbane buses — Live</h1>
    <div class="controls">
      <input id="routeFilter" type="text" placeholder="Filter by route number" />
      <button id="refreshBtn" title="Refresh">🔄</button>
    </div>
    <div class="controls-row">
      <button id="autoRefreshBtn" class="toggle-btn active" title="Auto-refresh (10s)">⏱️</button>
      <button id="locateBtn" title="My location">📍</button>
      <button id="toggleRoutesBtn" class="toggle-btn active" title="Toggle route lines">🛣️</button>
    </div>
    <div class="meta">
      <div>Current time: <span id="currentTime">—</span></div>
      <div>Last update: <span id="lastUpdate">—</span></div>
      <div>Vehicles shown: <span id="count">0</span></div>
    </div>
    <div class="legend">Source: Translink GTFS &amp; GTFS-RT (proxied) — Carto basemap</div>
  </div>

  <!-- Status bar -->
  <div id="statusBar">Initializing...</div>

  <!-- Debug toggle icon -->
  <div id="debugToggle" title="Toggle debug logs">🐛</div>

  <!-- Debug pane -->
  <div id="debugPane">
    <div class="debug-header">
      <span>Debug Logs</span>
      <div class="debug-controls">
        <button id="clearLogsBtn">Clear</button>
        <button id="closeDebugBtn">Close</button>
      </div>
    </div>
    <div class="debug-content" id="debugContent"></div>
  </div>

  <script src="https://unpkg.com/protobufjs@7.2.3/dist/protobuf.min.js"></script>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script>
    // Debug logging system
    const debugLogs = [];
    const statusBarEl = document.getElementById('statusBar');
    const debugToggleEl = document.getElementById('debugToggle');
    const debugPaneEl = document.getElementById('debugPane');
    const debugContentEl = document.getElementById('debugContent');
    const clearLogsBtnEl = document.getElementById('clearLogsBtn');
    const closeDebugBtnEl = document.getElementById('closeDebugBtn');

    function updateStatus(message) {
      if (statusBarEl) {
        statusBarEl.textContent = message;
      }
      logDebug(message, 'info');
    }

    function logDebug(message, level = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = { timestamp, message, level };
      debugLogs.push(logEntry);
      
      // Add to debug pane
      const entryEl = document.createElement('div');
      entryEl.className = `log-entry ${level}`;
      entryEl.innerHTML = `<span class="timestamp">${timestamp}</span><span class="message">${escapeHtml(message)}</span>`;
      debugContentEl.appendChild(entryEl);
      
      // Auto-scroll to bottom
      debugContentEl.scrollTop = debugContentEl.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function hideStatusBar() {
      if (statusBarEl) {
        statusBarEl.classList.add('hidden');
      }
    }

    function clearDebugLogs() {
      debugLogs.length = 0;
      debugContentEl.innerHTML = '';
    }

    // Toggle debug pane
    debugToggleEl.addEventListener('click', () => {
      debugPaneEl.classList.toggle('visible');
      debugToggleEl.classList.toggle('active');
    });

    clearLogsBtnEl.addEventListener('click', () => {
      clearDebugLogs();
      logDebug('Debug logs cleared', 'info');
    });

    closeDebugBtnEl.addEventListener('click', () => {
      debugPaneEl.classList.remove('visible');
      debugToggleEl.classList.remove('active');
    });

    // Capture console.error
    const originalConsoleError = console.error;
    console.error = function(...args) {
      logDebug('Error: ' + args.join(' '), 'error');
      originalConsoleError.apply(console, args);
    };

    // Global error handlers
    window.addEventListener('error', (event) => {
      logDebug(`Uncaught error: ${event.message} at ${event.filename}:${event.lineno}:${event.colno}`, 'error');
    });

    window.addEventListener('unhandledrejection', (event) => {
      logDebug(`Unhandled promise rejection: ${event.reason}`, 'error');
    });

    // Initialize
    logDebug('Application starting...', 'info');
    updateStatus('Initializing application...');

    const PROXY_FEED_URL = 'https://api.codetabs.com/v1/proxy?quest=https://gtfsrt.api.translink.com.au/api/realtime/SEQ/VehiclePositions';
    // Support both GitHub Pages (/brisbus/) and local dev
    const GTFS_BASE_URL = window.location.pathname.includes('/brisbus/') ? '/brisbus/data/' : '/data/';
    const PROTO_URL = 'https://raw.githubusercontent.com/google/transit/master/gtfs-realtime/proto/gtfs-realtime.proto';
    const REFRESH_INTERVAL_MS = 10000;
    const HISTORY_WINDOW_MS = 10 * 60 * 1000; // 10 minutes for trails

    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [153.0251, -27.4679],
      zoom: 11
    });
    map.addControl(new maplibregl.NavigationControl({showCompass: false}), 'top-right');

    let root = null, feedMessageType = null;
    let vehiclesGeoJSON = { type: 'FeatureCollection', features: [] };
    let vehicleHistory = {}; // vehicle_id → array of {coords, timestamp, speed}
    let allShapes = {};      // shape_id → Feature
    let routeToShapes = {};  // route_id → Set(shape_id)
    let allStops = {};       // stop_id → {stop_id, stop_name, stop_lat, stop_lon}
    let stopTimes = {};      // trip_id → array of {stop_id, stop_sequence, arrival_time, departure_time}
    let tripToRoute = {};    // trip_id → route_id
    let autoTimer = null;
    let userLocation = { type: 'FeatureCollection', features: [] };
    let showRoutes = true;  // Track whether to show route lines

    const lastUpdateEl = document.getElementById('lastUpdate');
    const countEl = document.getElementById('count');
    const currentTimeEl = document.getElementById('currentTime');
    const refreshBtn = document.getElementById('refreshBtn');
    const autoRefreshBtn = document.getElementById('autoRefreshBtn');
    const routeFilterEl = document.getElementById('routeFilter');
    const locateBtn = document.getElementById('locateBtn');
    const toggleRoutesBtn = document.getElementById('toggleRoutesBtn');

    // Update current time every second
    function updateCurrentTime() {
      const now = new Date();
      currentTimeEl.textContent = now.toLocaleTimeString();
    }
    updateCurrentTime();
    setInterval(updateCurrentTime, 1000);

    async function loadProto() {
      updateStatus('Loading protocol buffer definition...');
      const res = await fetch(PROTO_URL);
      const protoText = await res.text();
      const parsed = protobuf.parse(protoText);
      root = parsed.root;
      feedMessageType = root.lookupType('transit_realtime.FeedMessage');
      logDebug('Protocol buffer definition loaded successfully', 'info');
    }

    /**
     * Fetch and decompress a GTFS file
     * Uses brotli for WebKit browsers, gzip for everything else
     * WebKit has better brotli support via DecompressionStream
     */
    async function fetchAndDecompress(filename) {
      // Detect if we should use brotli (WebKit/Safari) or gzip (everything else)
      const isWebKit = /WebKit/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
      const useBrotli = isWebKit;
      
      if (useBrotli) {
        // Fetch and decompress brotli file for WebKit
        logDebug(`Fetching ${filename}.br...`, 'info');
        const res = await fetch(`${GTFS_BASE_URL}${filename}.br`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        // Use DecompressionStream to decompress brotli data
        const ds = new DecompressionStream('brotli');
        const decompressedStream = res.body.pipeThrough(ds);
        const decompressed = await new Response(decompressedStream).arrayBuffer();
        const text = new TextDecoder().decode(decompressed);
        
        logDebug(`Successfully loaded and decompressed ${filename}.br`, 'info');
        return text;
      } else {
        // Fetch and decompress gzip file for other browsers
        logDebug(`Fetching ${filename}.gz...`, 'info');
        const res = await fetch(`${GTFS_BASE_URL}${filename}.gz`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        // Use DecompressionStream to decompress gzip data
        const ds = new DecompressionStream('gzip');
        const decompressedStream = res.body.pipeThrough(ds);
        const decompressed = await new Response(decompressedStream).arrayBuffer();
        const text = new TextDecoder().decode(decompressed);
        
        logDebug(`Successfully loaded and decompressed ${filename}.gz`, 'info');
        return text;
      }
    }

    async function loadGTFS() {
      updateStatus('Loading GTFS data...');
      logDebug('Starting GTFS data load', 'info');
      
      // Fetch compressed files
      updateStatus('Downloading shapes data...');
      const shapesTxt = await fetchAndDecompress('shapes.txt');
      updateStatus('Downloading trips data...');
      const tripsTxt = await fetchAndDecompress('trips.txt');
      updateStatus('Downloading stops data...');
      const stopsTxt = await fetchAndDecompress('stops.txt');
      updateStatus('Downloading stop times data...');
      const stopTimesTxt = await fetchAndDecompress('stop_times.txt');

      // --- Parse shapes.txt ---
      updateStatus('Parsing shapes data...');
      const lines = shapesTxt.trim().split(/\r?\n/);
      const headers = lines.shift().split(",");
      const idx = Object.fromEntries(headers.map((h,i)=>[h,i]));
      const tmp = {};
      for (const line of lines) {
        const parts = line.split(",");
        const sid = parts[idx["shape_id"]];
        const lat = parseFloat(parts[idx["shape_pt_lat"]]);
        const lon = parseFloat(parts[idx["shape_pt_lon"]]);
        const seq = parseInt(parts[idx["shape_pt_sequence"]],10);
        if (!tmp[sid]) tmp[sid] = [];
        tmp[sid].push({seq, coord:[lon,lat]});
      }
      for (const sid in tmp) {
        tmp[sid].sort((a,b)=>a.seq-b.seq);
        allShapes[sid] = {
          type:"Feature",
          geometry:{type:"LineString", coordinates:tmp[sid].map(p=>p.coord)},
          properties:{shape_id:sid}
        };
      }
      logDebug(`Parsed ${Object.keys(allShapes).length} shapes`, 'info');

      // --- Parse trips.txt (route_id -> shape_id, trip_id -> route_id) ---
      updateStatus('Parsing trips data...');
      const tlines = tripsTxt.trim().split(/\r?\n/);
      const theaders = tlines.shift().split(",");
      const tidx = Object.fromEntries(theaders.map((h,i)=>[h,i]));
      for (const line of tlines) {
        const parts = line.split(",");
        const rid = parts[tidx["route_id"]];
        const sid = parts[tidx["shape_id"]];
        const tid = parts[tidx["trip_id"]];
        if (!rid || !sid) continue;
        if (!routeToShapes[rid]) routeToShapes[rid] = new Set();
        routeToShapes[rid].add(sid);
        if (tid) tripToRoute[tid] = rid;
      }
      logDebug(`Parsed ${Object.keys(routeToShapes).length} route mappings`, 'info');

      // --- Parse stops.txt ---
      updateStatus('Parsing stops data...');
      const slines = stopsTxt.trim().split(/\r?\n/);
      const sheaders = slines.shift().split(",");
      const sidx = Object.fromEntries(sheaders.map((h,i)=>[h,i]));
      for (const line of slines) {
        const parts = line.split(",");
        const stopId = parts[sidx["stop_id"]];
        const stopName = parts[sidx["stop_name"]] ? parts[sidx["stop_name"]].replace(/"/g, '') : '';
        const stopLat = parseFloat(parts[sidx["stop_lat"]]);
        const stopLon = parseFloat(parts[sidx["stop_lon"]]);
        if (stopId && !isNaN(stopLat) && !isNaN(stopLon)) {
          allStops[stopId] = { stop_id: stopId, stop_name: stopName, stop_lat: stopLat, stop_lon: stopLon };
        }
      }
      logDebug(`Parsed ${Object.keys(allStops).length} stops`, 'info');

      // --- Parse stop_times.txt ---
      updateStatus('Parsing stop times data...');
      const stlines = stopTimesTxt.trim().split(/\r?\n/);
      const stheaders = stlines.shift().split(",");
      const stidx = Object.fromEntries(stheaders.map((h,i)=>[h,i]));
      for (const line of stlines) {
        const parts = line.split(",");
        const tripId = parts[stidx["trip_id"]];
        const stopId = parts[stidx["stop_id"]];
        const stopSeq = parseInt(parts[stidx["stop_sequence"]], 10);
        const arrivalTime = parts[stidx["arrival_time"]];
        const departureTime = parts[stidx["departure_time"]];
        if (!tripId || !stopId) continue;
        if (!stopTimes[tripId]) stopTimes[tripId] = [];
        stopTimes[tripId].push({
          stop_id: stopId,
          stop_sequence: stopSeq,
          arrival_time: arrivalTime,
          departure_time: departureTime
        });
      }
      // Sort stop times by sequence
      for (const tripId in stopTimes) {
        stopTimes[tripId].sort((a, b) => a.stop_sequence - b.stop_sequence);
      }
      logDebug(`Parsed stop times for ${Object.keys(stopTimes).length} trips`, 'info');

      // Initialise empty layer
      updateStatus('Initializing map layers...');
      map.addSource("routes",{type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"route-lines",
        type:"line",
        source:"routes",
        paint:{
          "line-color":"#0077cc",
          "line-width":2,
          "line-opacity":0.6
        }
      });

      // Initialise user location layer
      map.addSource("user-location", { type: "geojson", data: userLocation });
      map.addLayer({
        id:"user-location-circle",
        type:"circle",
        source:"user-location",
        paint:{
          "circle-radius":10,
          "circle-color":"#0066ff",
          "circle-stroke-width":2,
          "circle-stroke-color":"#fff"
        }
      });

      // Initialise stops layer
      map.addSource("stops", { type: "geojson", data: { type: "FeatureCollection", features: [] } });
      map.addLayer({
        id: "stop-circles",
        type: "circle",
        source: "stops",
        paint: {
          "circle-radius": 4,
          "circle-color": "#ff6b6b",
          "circle-stroke-width": 1,
          "circle-stroke-color": "#fff",
          "circle-opacity": 0.8
        }
      });
      
      // Add click handler for stops
      map.on('click', 'stop-circles', (e) => {
        const props = e.features[0].properties;
        const stopId = props.stop_id;
        const stopName = props.stop_name;
        
        // Get upcoming arrivals for this stop
        const arrivals = getUpcomingArrivals(stopId);
        
        // Create popup HTML
        let html = `<div style="font-family: inherit; min-width: 220px; max-width: 320px; padding: 4px;">`;
        html += `<div style="font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #ff6b6b;">${stopName}</div>`;
        
        if (arrivals.length > 0) {
          html += `<div style="font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 6px;">Next arrivals (30 min):</div>`;
          html += '<div style="font-size: 12px; color: #666; line-height: 1.8;">';
          for (const arrival of arrivals) {
            const etaMin = Math.round(arrival.eta / 60);
            const etaColor = etaMin <= 2 ? '#F44336' : etaMin <= 5 ? '#FFC107' : '#4CAF50';
            html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: rgba(0,0,0,0.03); border-radius: 4px;">`;
            html += `<span><strong style="color: #0077cc;">${arrival.route}</strong> ${arrival.label}</span>`;
            html += `<span style="color: ${etaColor}; font-weight: 600;">${etaMin} min</span>`;
            html += `</div>`;
          }
          html += '</div>';
        } else {
          html += `<div style="font-size: 13px; color: #888;">No arrivals in the next 30 minutes</div>`;
        }
        
        html += '</div>';
        new maplibregl.Popup({
          maxWidth: '350px',
          className: 'custom-popup'
        }).setLngLat(e.lngLat).setHTML(html).addTo(map);
      });
      
      map.on('mouseenter', 'stop-circles', () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', 'stop-circles', () => map.getCanvas().style.cursor = '');
      
      logDebug('Map layers initialized', 'info');
    }

    async function fetchFeedAndUpdate() {
      try {
        logDebug('Fetching vehicle positions...', 'info');
        const res = await fetch(PROXY_FEED_URL, {cache: 'no-store'});
        if (!res.ok) throw new Error('Network response not ok: ' + res.status);
        const buffer = await res.arrayBuffer();
        const uint8 = new Uint8Array(buffer);
        const message = feedMessageType.decode(uint8);
        const object = feedMessageType.toObject(message, { longs: String, enums: String, bytes: String });
        const geojson = feedToGeoJSON(object);
        updateHistory(geojson);
        vehiclesGeoJSON = geojson;
        updateMapSource();
        // Display time with seconds
        const now = new Date();
        lastUpdateEl.textContent = now.toLocaleTimeString();
        countEl.textContent = geojson.features.length;
        logDebug(`Updated ${geojson.features.length} vehicle positions`, 'info');
      } catch (err) {
        logDebug('Error fetching feed: ' + err.message, 'error');
        lastUpdateEl.textContent = 'Error fetching feed';
      }
    }

    function feedToGeoJSON(feedObj) {
      const feats = [];
      if (!feedObj || !feedObj.entity) return { type: 'FeatureCollection', features: [] };
      for (const e of feedObj.entity) {
        if (!e.vehicle) continue;
        const vp = e.vehicle.position;
        if (!vp || vp.latitude == null || vp.longitude == null) continue;
        const props = {
          id: e.id || (e.vehicle.vehicle && e.vehicle.vehicle.id) || null,
          label: (e.vehicle.vehicle && `${e.vehicle.trip.routeId.split("-")[0]}: ${e.vehicle.vehicle.label}`) || null,
          route_id: e.vehicle.trip && e.vehicle.trip.routeId || null,
          trip_id: e.vehicle.trip && e.vehicle.trip.tripId || null,
          bearing: vp.bearing || null,
          speed: vp.speed || null,
          current_stop_sequence: e.vehicle.currentStopSequence || null,
          timestamp: e.vehicle.timestamp || null
        };
        feats.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [vp.longitude, vp.latitude] },
          properties: props
        });
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function updateHistory(currentGeoJSON) {
      const now = Date.now();
      for (const f of currentGeoJSON.features) {
        if (f.properties.timestamp && f.properties.id) {
          const vehicleId = f.properties.id;
          const tsMs = Number(f.properties.timestamp) * 1000;
          
          if (!vehicleHistory[vehicleId]) {
            vehicleHistory[vehicleId] = [];
          }
          
          // Add new position if it's not a duplicate
          const history = vehicleHistory[vehicleId];
          const isDuplicate = history.length > 0 && 
            history[history.length - 1].timestamp === tsMs;
          
          if (!isDuplicate) {
            history.push({
              coords: f.geometry.coordinates,
              timestamp: tsMs,
              speed: f.properties.speed || 0,
              route_id: f.properties.route_id,
              label: f.properties.label
            });
          }
        }
      }
      
      // Clean up old positions and empty vehicles
      for (const vehicleId in vehicleHistory) {
        vehicleHistory[vehicleId] = vehicleHistory[vehicleId].filter(
          pos => now - pos.timestamp <= HISTORY_WINDOW_MS
        );
        if (vehicleHistory[vehicleId].length === 0) {
          delete vehicleHistory[vehicleId];
        }
      }
    }

    function applyFilter(geojson) {
      const filterText = routeFilterEl.value.trim().toLowerCase();
      if (!filterText) return geojson;
      return {
        type: 'FeatureCollection',
        features: geojson.features.filter(f => {
          return (f.properties.route_id && f.properties.route_id.toLowerCase().includes(filterText)) ||
                 (f.properties.label && f.properties.label.toLowerCase().includes(filterText));
        })
      };
    }

    function buildTrailsGeoJSON() {
      const features = [];
      const filterText = routeFilterEl.value.trim().toLowerCase();
      
      for (const vehicleId in vehicleHistory) {
        const history = vehicleHistory[vehicleId];
        if (history.length < 2) continue; // Need at least 2 points for a line
        
        // Apply filter
        if (filterText) {
          const lastPos = history[history.length - 1];
          const matchesFilter = 
            (lastPos.route_id && lastPos.route_id.toLowerCase().includes(filterText)) ||
            (lastPos.label && lastPos.label.toLowerCase().includes(filterText));
          if (!matchesFilter) continue;
        }
        
        // Calculate average speed for the trail
        // First try to use reported speeds if available
        const speeds = history.map(h => h.speed || 0).filter(s => s > 0);
        let avgSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
        
        // If no reported speeds, calculate from position changes
        if (avgSpeed === 0 && history.length >= 2) {
          let totalDistance = 0;
          let totalTime = 0;
          
          for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            const timeDiff = (curr.timestamp - prev.timestamp) / 1000; // seconds
            
            if (timeDiff > 0) {
              const dist = haversineDistance(
                prev.coords[1], prev.coords[0],
                curr.coords[1], curr.coords[0]
              );
              totalDistance += dist;
              totalTime += timeDiff;
            }
          }
          
          if (totalTime > 0) {
            avgSpeed = totalDistance / totalTime; // meters per second
          }
        }
        
        features.push({
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: history.map(h => h.coords)
          },
          properties: {
            vehicle_id: vehicleId,
            speed: avgSpeed
          }
        });
      }
      
      return { type: 'FeatureCollection', features };
    }

    function calculateDistances(vehicleId) {
      const history = vehicleHistory[vehicleId];
      if (!history || history.length < 2) return [];
      
      const now = Date.now();
      const distances = [];
      const intervals = [10, 20, 30, 60, 120, 180, 300, 600]; // seconds
      
      for (const interval of intervals) {
        const targetTime = now - (interval * 1000);
        
        // Find the closest position in history to this time
        let closestPos = null;
        let minDiff = Infinity;
        
        for (const pos of history) {
          const diff = Math.abs(pos.timestamp - targetTime);
          if (diff < minDiff) {
            minDiff = diff;
            closestPos = pos;
          }
        }
        
        // Calculate distance if we found a position
        if (closestPos && minDiff < interval * 500) { // within half the interval
          const currentPos = history[history.length - 1];
          const distance = haversineDistance(
            closestPos.coords[1], closestPos.coords[0],
            currentPos.coords[1], currentPos.coords[0]
          );
          
          if (distance > 0) {
            const actualTimeDiff = (currentPos.timestamp - closestPos.timestamp) / 1000; // seconds
            const speedMps = actualTimeDiff > 0 ? distance / actualTimeDiff : 0; // m/s
            const speedKmh = Math.round(speedMps * 3.6); // convert to km/h
            distances.push({ 
              interval, 
              distance: Math.round(distance),
              speedKmh 
            });
          }
        }
      }
      
      return distances;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function formatInterval(seconds) {
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      if (secs === 0) return `${minutes}m`;
      return `${minutes}m ${secs}s`;
    }

    /**
     * Get upcoming arrivals at a stop within the next 30 minutes
     * Uses current vehicle positions and stop_times data
     */
    function getUpcomingArrivals(stopId) {
      const arrivals = [];
      const now = Date.now();
      const thirtyMinutesFromNow = now + (30 * 60 * 1000);
      
      // Get current time in HH:MM:SS format for schedule comparison
      const nowDate = new Date(now);
      const currentTimeSeconds = nowDate.getHours() * 3600 + nowDate.getMinutes() * 60 + nowDate.getSeconds();
      
      // Helper to convert HH:MM:SS to seconds since midnight
      function timeToSeconds(timeStr) {
        const parts = timeStr.split(':');
        let hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        // Handle times >= 24:00:00 (next day)
        if (hours >= 24) hours -= 24;
        return hours * 3600 + minutes * 60 + seconds;
      }
      
      // Look through all active vehicles to find ones approaching this stop
      for (const feature of vehiclesGeoJSON.features) {
        const tripId = feature.properties.trip_id;
        const routeId = feature.properties.route_id;
        const vehicleLabel = feature.properties.label;
        const currentStopSeq = feature.properties.current_stop_sequence;
        
        if (!tripId || !stopTimes[tripId]) continue;
        
        // Find this stop in the trip's stop times
        const stopTimeEntry = stopTimes[tripId].find(st => st.stop_id === stopId);
        if (!stopTimeEntry) continue;
        
        // Check if vehicle hasn't passed this stop yet
        if (currentStopSeq && stopTimeEntry.stop_sequence < currentStopSeq) continue;
        
        // Calculate ETA based on scheduled arrival time
        const scheduledArrivalSeconds = timeToSeconds(stopTimeEntry.arrival_time);
        let etaSeconds = scheduledArrivalSeconds - currentTimeSeconds;
        
        // Handle time wrapping around midnight
        if (etaSeconds < -12 * 3600) etaSeconds += 24 * 3600;
        if (etaSeconds > 12 * 3600) etaSeconds -= 24 * 3600;
        
        // Only include arrivals within next 30 minutes and not already passed
        if (etaSeconds >= 0 && etaSeconds <= 30 * 60) {
          arrivals.push({
            route: routeId ? routeId.split('-')[0] : '',
            label: vehicleLabel || '',
            eta: etaSeconds,
            scheduledTime: stopTimeEntry.arrival_time
          });
        }
      }
      
      // Sort by ETA
      arrivals.sort((a, b) => a.eta - b.eta);
      
      // Limit to 10 arrivals
      return arrivals.slice(0, 10);
    }

    function updateMapSource() {
      const filteredVehicles = applyFilter(vehiclesGeoJSON);
      const trailsGeoJSON = buildTrailsGeoJSON();

      // --- Filter shapes based on filter text ---
      const filterText = routeFilterEl.value.trim().toLowerCase();
      let routeIds = new Set();
      if (filterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(filterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      
      // Only build shape features if routes are enabled
      const shapeFeatures = showRoutes ? (function() {
        const features = [];
        for (const rid of routeIds) {
          const sids = routeToShapes[rid];
          if (!sids) continue;
          for (const sid of sids) {
            if (allShapes[sid]) features.push(allShapes[sid]);
          }
        }
        return features;
      })() : [];

      // Build stops features for active routes
      const stopFeatures = (function() {
        const features = [];
        const addedStops = new Set();
        
        // Get all trip IDs for active routes
        for (const feature of filteredVehicles.features) {
          const tripId = feature.properties.trip_id;
          if (!tripId || !stopTimes[tripId]) continue;
          
          // Add all stops for this trip
          for (const st of stopTimes[tripId]) {
            const stopId = st.stop_id;
            if (addedStops.has(stopId)) continue;
            
            const stop = allStops[stopId];
            if (!stop) continue;
            
            features.push({
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [stop.stop_lon, stop.stop_lat] },
              properties: {
                stop_id: stop.stop_id,
                stop_name: stop.stop_name
              }
            });
            addedStops.add(stopId);
          }
        }
        
        return features;
      })();

      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
        map.getSource('vehicle-trails').setData(trailsGeoJSON);
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
        map.getSource('stops').setData({type:"FeatureCollection",features:stopFeatures});
      } else {
        map.addSource('vehicles', { type: 'geojson', data: filteredVehicles });
        map.addLayer({
          id: 'vehicle-circles',
          type: 'circle',
          source: 'vehicles',
          paint: { 'circle-radius': 6, 'circle-stroke-width': 1, 'circle-stroke-color': '#fff' }
        });
        map.addLayer({
          id: 'vehicle-labels',
          type: 'symbol',
          source: 'vehicles',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ['get', 'route_id'], ''],
            'text-size': 12,
            'text-offset': [0, 1.3]
          }
        });
        map.on('click', 'vehicle-circles', (e) => {
          const props = e.features[0].properties;
          const vehicleId = props.id;
          
          // Create improved popup HTML
          let html = `<div style="font-family: inherit; min-width: 200px; max-width: 280px; padding: 4px;">`;
          html += `<div style="font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #0077cc; word-wrap: break-word;">${props.label || props.route_id || 'Vehicle'}</div>`;
          
          // Vehicle details
          html += `<div style="font-size: 13px; line-height: 1.6; color: #555;">`;
          html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Trip ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.trip_id || '—'}</strong></div>`;
          html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Vehicle ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.id || '—'}</strong></div>`;
          
          // Last seen time
          if (props.timestamp) {
            const lastSeenTime = new Date(Number(props.timestamp) * 1000);
            const timeStr = lastSeenTime.toLocaleTimeString();
            html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Last seen:</span> <strong>${timeStr}</strong></div>`;
          }
          
          // Add current speed if available
          if (vehicleId && vehicleHistory[vehicleId] && vehicleHistory[vehicleId].length >= 2) {
            const history = vehicleHistory[vehicleId];
            const lastPos = history[history.length - 1];
            const prevPos = history[history.length - 2];
            const timeDiff = (lastPos.timestamp - prevPos.timestamp) / 1000;
            
            if (timeDiff > 0) {
              const distance = haversineDistance(
                prevPos.coords[1], prevPos.coords[0],
                lastPos.coords[1], lastPos.coords[0]
              );
              const speedMps = distance / timeDiff;
              const speedKmh = Math.round(speedMps * 3.6);
              html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Current speed:</span> <strong style="color: #0077cc;">${speedKmh} km/h</strong></div>`;
            }
          }
          html += `</div>`;
          
          // Add distance history if available
          if (vehicleId && vehicleHistory[vehicleId]) {
            const distances = calculateDistances(vehicleId);
            if (distances.length > 0) {
              html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
              html += `<div style="font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 6px;">Distance traveled:</div>`;
              html += '<div style="font-size: 12px; color: #666; line-height: 1.8;">';
              for (const d of distances) {
                const avgSpeed = d.speedKmh;
                const speedColor = avgSpeed > 40 ? '#4CAF50' : avgSpeed > 20 ? '#FFC107' : '#888';
                html += `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;">`;
                html += `<span>${formatInterval(d.interval)}:</span>`;
                html += `<span><strong>${d.distance}m</strong> <span style="color: ${speedColor};">(${d.speedKmh} km/h)</span></span>`;
                html += `</div>`;
              }
              html += '</div></div>';
            }
          }
          
          html += '</div>';
          new maplibregl.Popup({
            maxWidth: '300px',
            className: 'custom-popup'
          }).setLngLat(e.lngLat).setHTML(html).addTo(map);
        });
        map.on('mouseenter', 'vehicle-circles', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vehicle-circles', () => map.getCanvas().style.cursor = '');

        map.addSource('vehicle-trails', { type: 'geojson', data: trailsGeoJSON });
        map.addLayer({
          id: 'vehicle-trails-lines',
          type: 'line',
          source: 'vehicle-trails',
          paint: {
            'line-width': 2,
            'line-color': [
              'interpolate',
              ['linear'],
              ['get', 'speed'],
              0, '#888888',      // Stationary: grey
              5, '#F44336',      // Slow: red (5 m/s ≈ 18 km/h)
              10, '#FF9800',     // Medium: orange (10 m/s ≈ 36 km/h)
              15, '#FFC107',     // Fast: amber (15 m/s ≈ 54 km/h)
              20, '#4CAF50'      // Very fast: green (20 m/s ≈ 72 km/h)
            ],
            'line-opacity': 0.6
          }
        }, 'vehicle-circles'); // Add trails below vehicle circles
        map.getSource("routes").setData({type:"FeatureCollection",features:shapeFeatures});
        map.getSource('stops').setData({type:"FeatureCollection",features:stopFeatures});
      }
    }

    refreshBtn.addEventListener('click', () => fetchFeedAndUpdate());
    routeFilterEl.addEventListener('input', () => updateMapSource());
    autoRefreshBtn.addEventListener('click', () => { 
      autoRefreshBtn.classList.toggle('active');
      if (autoRefreshBtn.classList.contains('active')) {
        startAutoRefresh();
      } else {
        stopAutoRefresh();
      }
    });
    locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) return alert('Geolocation not available');
      navigator.geolocation.getCurrentPosition(pos => {
        const coords = [pos.coords.longitude, pos.coords.latitude];
        userLocation.features = [{
          type: 'Feature',
          geometry: { type: 'Point', coordinates: coords }
        }];
        map.getSource('user-location').setData(userLocation);
        map.flyTo({ center: coords, zoom: 14 });
      }, e => alert('Unable to get location: ' + e.message));
    });
    
    toggleRoutesBtn.addEventListener('click', () => {
      toggleRoutesBtn.classList.toggle('active');
      showRoutes = toggleRoutesBtn.classList.contains('active');
      updateMapSource();
    });

    function startAutoRefresh() {
      stopAutoRefresh();
      autoTimer = setInterval(fetchFeedAndUpdate, REFRESH_INTERVAL_MS);
    }
    function stopAutoRefresh() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }

    (async function(){
      try {
        updateStatus('Loading protocol definitions...');
        await loadProto();
        updateStatus('Waiting for map to load...');
        map.on('load', async () => {
          try {
            logDebug('Map loaded successfully', 'info');
            await loadGTFS();
            updateStatus('Fetching initial vehicle data...');
            await fetchFeedAndUpdate();
            updateStatus('Starting auto-refresh...');
            startAutoRefresh();
            logDebug('Application initialized successfully', 'info');
            updateStatus('Ready! All systems operational.');
            // Hide status bar after 2 seconds
            setTimeout(() => {
              hideStatusBar();
            }, 2000);
          } catch (err) {
            logDebug('Error during map initialization: ' + err.message, 'error');
            updateStatus('Error during initialization');
            alert('Failed to load map data: ' + err.message);
          }
        });
      } catch (err) {
        logDebug('Startup error: ' + err.message, 'error');
        updateStatus('Startup error');
        alert('Failed to initialise: ' + err.message);
      }
    })();
  </script>
</body>
</html>
