<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="description" content="Live Brisbane bus tracking map using GTFS real-time data" />
  <meta name="theme-color" content="#0077cc" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Brisbane Buses" />
  <title>Brisbane Buses — Live Map (GTFS)</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    
    .ui { 
      position: absolute; 
      left: 12px; 
      top: 12px; 
      right: 12px;
      z-index: 2; 
      background: rgba(255,255,255,0.97); 
      padding: 14px 16px; 
      border-radius: 12px; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
      max-width: 420px;
      backdrop-filter: blur(10px);
    }
    
    .ui h1 { 
      margin: 0 0 12px 0; 
      font-size: 18px; 
      font-weight: 600;
      color: #1a1a1a;
      letter-spacing: -0.01em;
    }
    
    .controls { 
      display: flex; 
      gap: 8px; 
      align-items: stretch; 
      flex-wrap: nowrap; 
    }
    
    .input-wrapper {
      position: relative;
      flex: 1;
      min-width: 120px;
    }
    
    .controls input[type=text] { 
      width: 100%;
      padding: 11px 36px 11px 12px; 
      border-radius: 8px; 
      border: 1.5px solid #ddd; 
      font-size: 15px;
      background: #fff;
      transition: border-color 0.2s, box-shadow 0.2s;
      box-sizing: border-box;
    }
    
    .controls input[type=text]:focus { 
      outline: none;
      border-color: #0077cc;
      box-shadow: 0 0 0 3px rgba(0, 119, 204, 0.1);
    }
    
    .clear-btn {
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 16px;
      color: #888;
      display: none;
      box-shadow: none;
      transition: color 0.2s;
      line-height: 1;
    }
    
    .clear-btn:hover {
      color: #333;
      background: transparent;
      border: none;
      box-shadow: none;
      transform: translateY(-50%);
    }
    
    .clear-btn:active {
      transform: translateY(-50%);
    }
    
    .clear-btn.visible {
      display: block;
    }
    
    button { 
      padding: 11px 14px; 
      border-radius: 8px; 
      border: 1.5px solid #d0d0d0; 
      background: linear-gradient(to bottom, #fff, #f8f8f8); 
      cursor: pointer; 
      font-size: 18px;
      font-weight: 500;
      color: #333;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.15s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      white-space: nowrap;
      line-height: 1;
    }
    
    button:hover { 
      background: linear-gradient(to bottom, #f8f8f8, #f0f0f0);
      border-color: #b8b8b8;
      box-shadow: 0 2px 4px rgba(0,0,0,0.12);
    }
    
    button:active { 
      background: #e8e8e8;
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }
    
    .toggle-btn.active {
      background: linear-gradient(to bottom, #0077cc, #0066b3);
      border-color: #0055aa;
      color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    
    .toggle-btn.active:hover {
      background: linear-gradient(to bottom, #0066b3, #005599);
      border-color: #004488;
    }
    
    /* Follow mode indicator */
    .follow-indicator {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 119, 204, 0.95);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 10;
      display: none;
      animation: slideUp 0.3s ease-out;
    }
    
    .follow-indicator.visible {
      display: block;
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    
    

    
    .meta { 
      margin-top: 12px; 
      padding-top: 12px;
      border-top: 1px solid #e8e8e8;
      font-size: 14px; 
      color: #555;
      line-height: 1.6;
    }
    
    .meta div {
      margin-bottom: 4px;
    }
    
    .meta span {
      font-weight: 500;
      color: #1a1a1a;
    }
    
    .legend { 
      margin-top: 10px; 
      padding-top: 10px;
      border-top: 1px solid #e8e8e8;
      font-size: 12px; 
      color: #777; 
      line-height: 1.5; 
    }
    
    /* Custom popup styling */
    .maplibregl-popup-content {
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      padding: 12px 14px;
    }
    
    .maplibregl-popup-close-button {
      font-size: 20px;
      padding: 4px 8px;
      color: #888;
    }
    
    .maplibregl-popup-close-button:hover {
      background: #f0f0f0;
      color: #333;
    }
    
    /* Mobile responsive styles */
    @media (max-width: 768px) {
      .ui {
        left: 10px;
        right: 10px;
        top: 10px;
        padding: 10px;
        max-width: none;
      }
      
      .ui h1 {
        font-size: 16px;
        margin-bottom: 8px;
      }
      
      .controls {
        gap: 6px;
      }
      
      .input-wrapper {
        min-width: 0;
      }
      
      .controls input[type=text] {
        padding: 10px 36px 10px 10px;
        font-size: 16px; /* Prevent zoom on iOS */
      }
      
      button {
        padding: 10px 12px;
        font-size: 14px;
        white-space: nowrap;
      }
      
      .meta {
        margin-top: 8px;
        padding-top: 8px;
        font-size: 13px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      
      .meta div {
        margin-bottom: 0;
        white-space: nowrap;
      }
      
      .legend {
        display: none; /* Hide on mobile */
      }
    }
    
    @media (max-width: 640px) {
      .ui {
        padding: 8px;
      }
      
      .ui h1 { 
        font-size: 15px; 
        margin-bottom: 6px;
      }
      
      .controls { 
        gap: 4px;
      }
      
      .controls input[type=text] { 
        padding: 9px 32px 9px 8px;
      }
      
      button { 
        padding: 9px 10px; 
        font-size: 13px;
      }
      
      .meta { 
        font-size: 12px; 
        margin-top: 6px;
        padding-top: 6px;
      }
    }
    
    @media (max-width: 400px) {
      .ui {
        left: 8px;
        right: 8px;
        top: 8px;
        padding: 6px;
      }
      
      .ui h1 {
        font-size: 14px;
        margin-bottom: 4px;
      }
      
      .controls { 
        gap: 3px;
      }
      
      .controls input[type=text] { 
        padding: 8px 28px 8px 6px;
        font-size: 16px;
      }
      
      button {
        padding: 8px 8px;
        font-size: 12px;
      }
      
      .meta {
        font-size: 11px;
        margin-top: 4px;
        padding-top: 4px;
      }
    }
    
    /* Status bar */
    #statusBar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 119, 204, 0.95);
      color: white;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      z-index: 1000;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.15);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    #statusBar.hidden {
      transform: translateY(100%);
      opacity: 0;
    }
    
    /* Debug toggle icon */
    #debugToggle {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.9);
      border: 1.5px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      z-index: 999;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: all 0.2s ease;
      user-select: none;
    }
    
    #debugToggle:hover {
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 3px 12px rgba(0,0,0,0.2);
      transform: scale(1.05);
    }
    
    #debugToggle.active {
      background: rgba(0, 119, 204, 0.95);
      color: white;
      border-color: #0055aa;
    }
    
    /* Debug pane */
    #debugPane {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40vh;
      background: rgba(30, 30, 30, 0.97);
      color: #e0e0e0;
      z-index: 998;
      display: flex;
      flex-direction: column;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    
    #debugPane.visible {
      transform: translateY(0);
    }
    
    #debugPane .debug-header {
      padding: 10px 16px;
      background: rgba(0, 119, 204, 0.9);
      color: white;
      font-weight: 600;
      font-size: 14px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #debugPane .debug-controls {
      display: flex;
      gap: 8px;
    }
    
    #debugPane .debug-controls button {
      padding: 4px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }
    
    #debugPane .debug-controls button:hover {
      background: rgba(255,255,255,0.3);
    }
    
    #debugPane .debug-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px 16px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
      font-size: 12px;
      line-height: 1.6;
    }
    
    #debugPane .log-entry {
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      border-left: 3px solid #888;
    }
    
    #debugPane .log-entry.info {
      border-left-color: #4CAF50;
    }
    
    #debugPane .log-entry.error {
      border-left-color: #F44336;
      background: rgba(244, 67, 54, 0.1);
    }
    
    #debugPane .log-entry.warn {
      border-left-color: #FFC107;
    }
    
    #debugPane .log-entry .timestamp {
      color: #888;
      font-size: 11px;
      margin-right: 8px;
    }
    
    #debugPane .log-entry .message {
      color: #e0e0e0;
    }
    
    #debugPane .log-entry.error .message {
      color: #ffcdd2;
    }
    
    @media (max-width: 768px) {
      #debugPane {
        height: 50vh;
      }
      
      #debugToggle {
        width: 28px;
        height: 28px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Follow mode indicator -->
  <div id="followIndicator" class="follow-indicator">
    <span id="followIndicatorText">Following vehicle...</span>
  </div>
  
  <div class="ui">
    <h1>Brisbane buses — Live</h1>
    <div class="controls">
      <div class="input-wrapper">
        <input id="routeFilter" type="text" placeholder="Route" />
        <button id="clearBtn" class="clear-btn" title="Clear filter">✕</button>
      </div>
      <button id="refreshBtn" title="Refresh">🔄</button>
      <button id="autoRefreshBtn" class="toggle-btn active" title="Auto-refresh (10s)">⏱️</button>
      <button id="locateBtn" title="My location">📍</button>
      <button id="toggleRoutesBtn" class="toggle-btn active" title="Toggle route lines">🛣️</button>
      <button id="slideshowBtn" class="toggle-btn" title="Slideshow mode">🎬</button>
    </div>
    <div class="meta">
      <div>Current time: <span id="currentTime">—</span></div>
      <div>Last update: <span id="lastUpdate">—</span></div>
      <div>Vehicles shown: <span id="count">0</span></div>
    </div>
    <div class="legend">Source: Translink GTFS &amp; GTFS-RT (proxied) — Carto basemap</div>
  </div>

  <!-- Status bar -->
  <div id="statusBar">Initializing...</div>

  <!-- Debug toggle icon -->
  <div id="debugToggle" title="Toggle debug logs">🐛</div>

  <!-- Debug pane -->
  <div id="debugPane">
    <div class="debug-header">
      <span>Debug Logs</span>
      <div class="debug-controls">
        <button id="clearLogsBtn">Clear</button>
        <button id="closeDebugBtn">Close</button>
      </div>
    </div>
    <div class="debug-content" id="debugContent"></div>
  </div>

  <script src="https://unpkg.com/protobufjs@7.2.3/dist/protobuf.min.js"></script>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script>
    // Debug logging system
    const debugLogs = [];
    const MAX_DEBUG_LOGS = 500; // Limit debug logs to prevent unbounded memory growth
    const statusBarEl = document.getElementById('statusBar');
    const debugToggleEl = document.getElementById('debugToggle');
    const debugPaneEl = document.getElementById('debugPane');
    const debugContentEl = document.getElementById('debugContent');
    const clearLogsBtnEl = document.getElementById('clearLogsBtn');
    const closeDebugBtnEl = document.getElementById('closeDebugBtn');

    function updateStatus(message) {
      if (statusBarEl) {
        statusBarEl.textContent = message;
      }
      logDebug(message, 'info');
    }

    function logDebug(message, level = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = { timestamp, message, level };
      debugLogs.push(logEntry);
      
      // Limit array size to prevent unbounded growth
      if (debugLogs.length > MAX_DEBUG_LOGS) {
        debugLogs.shift();
        // Remove oldest DOM element from debug pane
        if (debugContentEl.firstChild) {
          debugContentEl.removeChild(debugContentEl.firstChild);
        }
      }
      
      // Add to debug pane
      const entryEl = document.createElement('div');
      entryEl.className = `log-entry ${level}`;
      entryEl.innerHTML = `<span class="timestamp">${timestamp}</span><span class="message">${escapeHtml(message)}</span>`;
      debugContentEl.appendChild(entryEl);
      
      // Auto-scroll to bottom
      debugContentEl.scrollTop = debugContentEl.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function hideStatusBar() {
      if (statusBarEl) {
        statusBarEl.classList.add('hidden');
      }
    }

    function clearDebugLogs() {
      debugLogs.length = 0;
      debugContentEl.innerHTML = '';
    }

    // Toggle debug pane
    debugToggleEl.addEventListener('click', () => {
      debugPaneEl.classList.toggle('visible');
      debugToggleEl.classList.toggle('active');
    });

    clearLogsBtnEl.addEventListener('click', () => {
      clearDebugLogs();
      logDebug('Debug logs cleared', 'info');
    });

    closeDebugBtnEl.addEventListener('click', () => {
      debugPaneEl.classList.remove('visible');
      debugToggleEl.classList.remove('active');
    });

    // Capture console.error
    const originalConsoleError = console.error;
    console.error = function(...args) {
      logDebug('Error: ' + args.join(' '), 'error');
      originalConsoleError.apply(console, args);
    };

    // Global error handlers
    window.addEventListener('error', (event) => {
      logDebug(`Uncaught error: ${event.message} at ${event.filename}:${event.lineno}:${event.colno}`, 'error');
    });

    window.addEventListener('unhandledrejection', (event) => {
      logDebug(`Unhandled promise rejection: ${event.reason}`, 'error');
    });

    // Initialize
    logDebug('Application starting...', 'info');
    updateStatus('Initializing application...');

    const PROXY_FEED_URL = 'https://api.codetabs.com/v1/proxy?quest=https://gtfsrt.api.translink.com.au/api/realtime/SEQ/VehiclePositions';
    // Support both GitHub Pages (/brisbus/) and local dev
    const GTFS_BASE_URL = window.location.pathname.includes('/brisbus/') ? '/brisbus/data/' : '/data/';
    const PROTO_URL = 'https://raw.githubusercontent.com/google/transit/master/gtfs-realtime/proto/gtfs-realtime.proto';
    const REFRESH_INTERVAL_MS = 10000;
    const HISTORY_WINDOW_MS = 10 * 60 * 1000; // 10 minutes for trails

    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [153.0251, -27.4679],
      zoom: 11
    });
    map.addControl(new maplibregl.NavigationControl({showCompass: false}), 'top-right');

    let root = null, feedMessageType = null;
    let vehiclesGeoJSON = { type: 'FeatureCollection', features: [] };
    let vehicleHistory = {}; // vehicle_id → array of {coords, timestamp, speed}
    let allShapes = {};      // shape_id → Feature
    let routeToShapes = {};  // route_id → Set(shape_id)
    let tripToShape = {};    // trip_id → shape_id
    let allStops = {};       // stop_id → {lat, lon, name, ...}
    let tripStopTimes = {};  // trip_id → array of {stop_id, arrival_time (seconds), departure_time (seconds), stop_sequence}
    let routeStops = {};     // route_id → Set(stop_id)
    let autoTimer = null;
    let userLocation = { type: 'FeatureCollection', features: [] };
    let showRoutes = true;  // Track whether to show route lines
    let cachedFilterText = ''; // Cache the current filter text
    
    // Animation state
    let animationStartTime = null;
    let animationInProgress = false;
    let previousPositions = {};  // vehicle_id → coordinates
    let targetPositions = {};    // vehicle_id → coordinates
    const ANIMATION_DURATION_MS = 2000;  // 2 seconds
    
    // Slideshow/follow mode state
    let slideshowActive = false;
    let followModeActive = false;
    let slideshowTimer = null;
    let rotationAnimationId = null; // Changed from rotationTimer to animationId
    let currentFollowedVehicle = null;
    let currentRotationAngle = 0;
    let currentFollowPopup = null; // Track current popup for updates
    let rotationStartTime = null; // Track when rotation started
    const SLIDESHOW_DURATION_MS = 30000; // 30 seconds per vehicle
    const ROTATION_SPEED = 360 / 60; // Complete 360° rotation in 60 seconds (6° per second) - slower rotation

    const lastUpdateEl = document.getElementById('lastUpdate');
    const countEl = document.getElementById('count');
    const currentTimeEl = document.getElementById('currentTime');
    const refreshBtn = document.getElementById('refreshBtn');
    const autoRefreshBtn = document.getElementById('autoRefreshBtn');
    const routeFilterEl = document.getElementById('routeFilter');
    const clearBtn = document.getElementById('clearBtn');
    const locateBtn = document.getElementById('locateBtn');
    const toggleRoutesBtn = document.getElementById('toggleRoutesBtn');
    const slideshowBtn = document.getElementById('slideshowBtn');
    const followIndicator = document.getElementById('followIndicator');
    const followIndicatorText = document.getElementById('followIndicatorText');

    // Update current time every second
    function updateCurrentTime() {
      const now = new Date();
      currentTimeEl.textContent = now.toLocaleTimeString();
    }
    updateCurrentTime();
    setInterval(updateCurrentTime, 1000);

    async function loadProto() {
      updateStatus('Loading protocol buffer definition...');
      const res = await fetch(PROTO_URL);
      const protoText = await res.text();
      const parsed = protobuf.parse(protoText);
      root = parsed.root;
      feedMessageType = root.lookupType('transit_realtime.FeedMessage');
      logDebug('Protocol buffer definition loaded successfully', 'info');
    }

    /**
     * Fetch and decompress a GTFS file
     * Uses brotli for WebKit browsers, gzip for everything else
     * WebKit has better brotli support via DecompressionStream
     */
    async function fetchAndDecompress(filename) {
      // Detect if we should use brotli (WebKit/Safari) or gzip (everything else)
      const isWebKit = /WebKit/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
      const useBrotli = isWebKit;
      
      if (useBrotli) {
        // Fetch and decompress brotli file for WebKit
        logDebug(`Fetching ${filename}.br...`, 'info');
        const res = await fetch(`${GTFS_BASE_URL}${filename}.br`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        // Use DecompressionStream to decompress brotli data
        const ds = new DecompressionStream('brotli');
        const decompressedStream = res.body.pipeThrough(ds);
        const decompressed = await new Response(decompressedStream).arrayBuffer();
        const text = new TextDecoder().decode(decompressed);
        
        logDebug(`Successfully loaded and decompressed ${filename}.br`, 'info');
        return text;
      } else {
        // Fetch and decompress gzip file for other browsers
        logDebug(`Fetching ${filename}.gz...`, 'info');
        const res = await fetch(`${GTFS_BASE_URL}${filename}.gz`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        // Use DecompressionStream to decompress gzip data
        const ds = new DecompressionStream('gzip');
        const decompressedStream = res.body.pipeThrough(ds);
        const decompressed = await new Response(decompressedStream).arrayBuffer();
        const text = new TextDecoder().decode(decompressed);
        
        logDebug(`Successfully loaded and decompressed ${filename}.gz`, 'info');
        return text;
      }
    }

    /**
     * Parse a CSV line properly handling quoted fields with commas
     * @param {string} line - A single CSV line
     * @returns {string[]} - Array of field values
     */
    function parseCSVLine(line) {
      const fields = [];
      let currentField = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
          // Toggle quote state
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          // End of field
          fields.push(currentField);
          currentField = '';
        } else {
          // Add character to current field
          currentField += char;
        }
      }
      
      // Add the last field
      fields.push(currentField);
      
      return fields;
    }

    /**
     * Load and parse shapes data
     */
    async function loadAndParseShapes() {
      const shapesTxt = await fetchAndDecompress('shapes.txt');
      
      updateStatus('Parsing shapes data...');
      const lines = shapesTxt.trim().split(/\r?\n/);
      const headers = parseCSVLine(lines.shift());
      const idx = Object.fromEntries(headers.map((h,i)=>[h,i]));
      const tmp = {};
      for (const line of lines) {
        const parts = parseCSVLine(line);
        const sid = parts[idx["shape_id"]];
        const lat = parseFloat(parts[idx["shape_pt_lat"]]);
        const lon = parseFloat(parts[idx["shape_pt_lon"]]);
        const seq = parseInt(parts[idx["shape_pt_sequence"]],10);
        if (!tmp[sid]) tmp[sid] = [];
        tmp[sid].push({seq, coord:[lon,lat]});
      }
      // Process shapes and free tmp memory progressively
      for (const sid in tmp) {
        tmp[sid].sort((a,b)=>a.seq-b.seq);
        const coords = new Array(tmp[sid].length);
        for (let i = 0; i < tmp[sid].length; i++) {
          coords[i] = tmp[sid][i].coord;
        }
        allShapes[sid] = {
          type:"Feature",
          geometry:{type:"LineString", coordinates:coords},
          properties:{shape_id:sid}
        };
        // Free memory for this shape's temp data
        delete tmp[sid];
      }
      logDebug(`Parsed ${Object.keys(allShapes).length} shapes`, 'info');
    }

    /**
     * Load and parse trips data
     */
    async function loadAndParseTrips() {
      const tripsTxt = await fetchAndDecompress('trips.txt');
      
      updateStatus('Parsing trips data...');
      let firstLine = true;
      let tidx = {};
      const tripToRoute = {}; // trip_id → route_id
      
      // Parse line by line to avoid keeping full array in memory
      const lines = tripsTxt.split(/\r?\n/);
      for (const line of lines) {
        if (!line.trim()) continue;
        
        if (firstLine) {
          const theaders = parseCSVLine(line);
          tidx = Object.fromEntries(theaders.map((h,i)=>[h,i]));
          firstLine = false;
          continue;
        }
        
        const parts = parseCSVLine(line);
        const rid = parts[tidx["route_id"]];
        const sid = parts[tidx["shape_id"]];
        const tripId = parts[tidx["trip_id"]];
        if (!rid || !sid) continue;
        if (!routeToShapes[rid]) routeToShapes[rid] = new Set();
        routeToShapes[rid].add(sid);
        if (tripId) {
          tripToRoute[tripId] = rid;
          tripToShape[tripId] = sid;
        }
      }
      logDebug(`Parsed ${Object.keys(routeToShapes).length} route mappings`, 'info');
      return tripToRoute;
    }

    /**
     * Load and parse stops data
     */
    async function loadAndParseStops() {
      const stopsTxt = await fetchAndDecompress('stops.txt');
      
      updateStatus('Parsing stops data...');
      let firstLine = true;
      let stopIdx = {};
      
      const lines = stopsTxt.split(/\r?\n/);
      for (const line of lines) {
        if (!line.trim()) continue;
        
        if (firstLine) {
          const stopHeaders = parseCSVLine(line);
          stopIdx = Object.fromEntries(stopHeaders.map((h,i)=>[h,i]));
          firstLine = false;
          continue;
        }
        
        const parts = parseCSVLine(line);
        const stopId = parts[stopIdx["stop_id"]];
        const stopName = parts[stopIdx["stop_name"]] || '';
        const stopLat = parseFloat(parts[stopIdx["stop_lat"]]);
        const stopLon = parseFloat(parts[stopIdx["stop_lon"]]);
        if (stopId && !isNaN(stopLat) && !isNaN(stopLon)) {
          allStops[stopId] = {
            id: stopId,
            name: stopName,
            lat: stopLat,
            lon: stopLon
          };
        }
      }
      logDebug(`Parsed ${Object.keys(allStops).length} stops`, 'info');
    }

    /**
     * Load and parse stop times data
     * Optimized to reduce memory usage by converting time strings to integers (seconds since midnight)
     */
    async function loadAndParseStopTimes(tripToRoute) {
      const stopTimesTxt = await fetchAndDecompress('stop_times.txt');
      
      updateStatus('Parsing stop times data...');
      let firstLine = true;
      let stopTimeIdx = {};
      
      const lines = stopTimesTxt.split(/\r?\n/);
      for (const line of lines) {
        if (!line.trim()) continue;
        
        if (firstLine) {
          const stopTimeHeaders = parseCSVLine(line);
          stopTimeIdx = Object.fromEntries(stopTimeHeaders.map((h,i)=>[h,i]));
          firstLine = false;
          continue;
        }
        
        const parts = parseCSVLine(line);
        const tripId = parts[stopTimeIdx["trip_id"]];
        const stopId = parts[stopTimeIdx["stop_id"]];
        const arrivalTimeStr = parts[stopTimeIdx["arrival_time"]];
        const departureTimeStr = parts[stopTimeIdx["departure_time"]];
        const stopSequence = parseInt(parts[stopTimeIdx["stop_sequence"]], 10);
        
        if (tripId && stopId && arrivalTimeStr) {
          // Convert time strings to seconds (integer)
          const arrivalTimeSeconds = parseGtfsTime(arrivalTimeStr);
          const departureTimeSeconds = departureTimeStr ? parseGtfsTime(departureTimeStr) : arrivalTimeSeconds;
          
          if (!tripStopTimes[tripId]) tripStopTimes[tripId] = [];
          tripStopTimes[tripId].push({
            stop_id: stopId,
            arrival_time: arrivalTimeSeconds,  // Now stored as integer (seconds)
            departure_time: departureTimeSeconds,  // Now stored as integer (seconds)
            stop_sequence: stopSequence
          });
          
          // Build route -> stops mapping
          const routeId = tripToRoute[tripId];
          if (routeId) {
            if (!routeStops[routeId]) routeStops[routeId] = new Set();
            routeStops[routeId].add(stopId);
          }
        }
      }
      logDebug(`Parsed stop times for ${Object.keys(tripStopTimes).length} trips`, 'info');
    }

    async function loadGTFS() {
      updateStatus('Loading GTFS data...');
      logDebug('Starting GTFS data load', 'info');
      
      // Load shapes, trips, and stops in parallel for faster initial load
      // Memory is now optimized with integer times and time-window filtering
      updateStatus('Downloading and parsing GTFS data...');
      const [_, tripToRoute, __] = await Promise.all([
        loadAndParseShapes(),
        loadAndParseTrips(),
        loadAndParseStops()
      ]);

      // Parse stop_times after trips are loaded (needs tripToRoute mapping)
      await loadAndParseStopTimes(tripToRoute);

      // Initialise empty layer
      updateStatus('Initializing map layers...');
      map.addSource("routes",{type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"route-lines",
        type:"line",
        source:"routes",
        paint:{
          "line-color":"#0077cc",
          "line-width":2,
          "line-opacity":0.6
        }
      });

      // Initialise stops layer
      map.addSource("stops", {type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"stop-circles",
        type:"circle",
        source:"stops",
        paint:{
          "circle-radius":3,
          "circle-color":"#9E9E9E",
          "circle-stroke-width":1,
          "circle-stroke-color":"#fff",
          "circle-opacity":0.7
        }
      });

      // Initialise user location layer
      map.addSource("user-location", { type: "geojson", data: userLocation });
      map.addLayer({
        id:"user-location-circle",
        type:"circle",
        source:"user-location",
        paint:{
          "circle-radius":7,
          "circle-color":"#0066ff",
          "circle-stroke-width":2,
          "circle-stroke-color":"#fff"
        }
      });
      logDebug('Map layers initialized', 'info');
    }

    async function fetchFeedAndUpdate() {
      try {
        logDebug('Fetching vehicle positions...', 'info');
        const res = await fetch(PROXY_FEED_URL, {cache: 'no-store'});
        if (!res.ok) throw new Error('Network response not ok: ' + res.status);
        const buffer = await res.arrayBuffer();
        const uint8 = new Uint8Array(buffer);
        const message = feedMessageType.decode(uint8);
        const object = feedMessageType.toObject(message, { longs: String, enums: String, bytes: String });
        const geojson = feedToGeoJSON(object);
        updateHistory(geojson);
        
        // Check if this is the first load (source doesn't exist yet)
        if (!map.getSource('vehicles')) {
          // First load: set up layers without animation
          vehiclesGeoJSON = geojson;
          updateMapSource();
        } else {
          // Subsequent updates: use smooth animation for position updates
          startPositionAnimation(geojson);
          
          // Update trails and routes (these don't need animation)
          updateMapSourceNonAnimated();
        }
        
        // Display time with seconds
        const now = new Date();
        lastUpdateEl.textContent = now.toLocaleTimeString();
        countEl.textContent = geojson.features.length;
        logDebug(`Updated ${geojson.features.length} vehicle positions`, 'info');
      } catch (err) {
        logDebug('Error fetching feed: ' + err.message, 'error');
        lastUpdateEl.textContent = 'Error fetching feed';
      }
    }

    function feedToGeoJSON(feedObj) {
      const feats = [];
      if (!feedObj || !feedObj.entity) return { type: 'FeatureCollection', features: [] };
      for (const e of feedObj.entity) {
        if (!e.vehicle) continue;
        const vp = e.vehicle.position;
        if (!vp || vp.latitude == null || vp.longitude == null) continue;
        const vehicleId = e.id || (e.vehicle.vehicle && e.vehicle.vehicle.id) || null;
        const props = {
          id: vehicleId,
          label: (e.vehicle.trip && e.vehicle.trip.routeId && e.vehicle.trip.routeId.split("-")[0]) || null,
          human_readable_id: (e.vehicle.vehicle && e.vehicle.vehicle.label) || null,
          route_id: e.vehicle.trip && e.vehicle.trip.routeId || null,
          trip_id: e.vehicle.trip && e.vehicle.trip.tripId || null,
          bearing: vp.bearing || null,
          speed: vp.speed || null,
          current_stop_sequence: e.vehicle.currentStopSequence || null,
          timestamp: e.vehicle.timestamp || null
        };
        feats.push({
          type: 'Feature',
          id: vehicleId,  // Add feature ID for smooth animations
          geometry: { type: 'Point', coordinates: [vp.longitude, vp.latitude] },
          properties: props
        });
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function updateHistory(currentGeoJSON) {
      const now = Date.now();
      const activeVehicleIds = new Set();
      
      for (const f of currentGeoJSON.features) {
        if (f.properties.timestamp && f.properties.id) {
          const vehicleId = f.properties.id;
          activeVehicleIds.add(vehicleId);
          const tsMs = Number(f.properties.timestamp) * 1000;
          
          if (!vehicleHistory[vehicleId]) {
            vehicleHistory[vehicleId] = [];
          }
          
          // Add new position if it's not a duplicate
          const history = vehicleHistory[vehicleId];
          const isDuplicate = history.length > 0 && 
            history[history.length - 1].timestamp === tsMs;
          
          if (!isDuplicate) {
            history.push({
              coords: f.geometry.coordinates,
              timestamp: tsMs,
              speed: f.properties.speed || 0,
              route_id: f.properties.route_id,
              trip_id: f.properties.trip_id,
              label: f.properties.label
            });
          }
        }
      }
      
      // Clean up old positions and empty vehicles
      for (const vehicleId in vehicleHistory) {
        vehicleHistory[vehicleId] = vehicleHistory[vehicleId].filter(
          pos => now - pos.timestamp <= HISTORY_WINDOW_MS
        );
        if (vehicleHistory[vehicleId].length === 0) {
          delete vehicleHistory[vehicleId];
          // Also clean up animation state for removed vehicles
          delete previousPositions[vehicleId];
          delete targetPositions[vehicleId];
        }
      }
      
      // Clean up animation positions for vehicles no longer in history
      for (const vehicleId in previousPositions) {
        if (!vehicleHistory[vehicleId]) {
          delete previousPositions[vehicleId];
        }
      }
      for (const vehicleId in targetPositions) {
        if (!vehicleHistory[vehicleId]) {
          delete targetPositions[vehicleId];
        }
      }
    }

    function applyFilter(geojson) {
      if (!cachedFilterText) return geojson;
      return {
        type: 'FeatureCollection',
        features: geojson.features.filter(f => {
          return (f.properties.route_id && f.properties.route_id.toLowerCase().includes(cachedFilterText)) ||
                 (f.properties.label && f.properties.label.toLowerCase().includes(cachedFilterText));
        })
      };
    }

    /**
     * Find the closest point on a line segment to a given point
     * Returns the closest point and distance to it
     */
    function closestPointOnSegment(point, segStart, segEnd) {
      const [px, py] = point;
      const [ax, ay] = segStart;
      const [bx, by] = segEnd;
      
      const dx = bx - ax;
      const dy = by - ay;
      
      if (dx === 0 && dy === 0) {
        // Segment is a point
        const dist = Math.sqrt((px - ax) ** 2 + (py - ay) ** 2);
        return { point: [ax, ay], distance: dist, t: 0 };
      }
      
      // Project point onto line segment
      const t = Math.max(0, Math.min(1, ((px - ax) * dx + (py - ay) * dy) / (dx * dx + dy * dy)));
      const closestX = ax + t * dx;
      const closestY = ay + t * dy;
      const dist = Math.sqrt((px - closestX) ** 2 + (py - closestY) ** 2);
      
      return { point: [closestX, closestY], distance: dist, t };
    }

    /**
     * Find the closest point on a route shape to a given coordinate
     * Returns { point, segmentIndex, t, distance }
     */
    function findClosestPointOnShape(coord, shapeCoords) {
      let minDistance = Infinity;
      let closestResult = null;
      
      for (let i = 0; i < shapeCoords.length - 1; i++) {
        const result = closestPointOnSegment(coord, shapeCoords[i], shapeCoords[i + 1]);
        if (result.distance < minDistance) {
          minDistance = result.distance;
          closestResult = {
            point: result.point,
            segmentIndex: i,
            t: result.t,
            distance: result.distance
          };
        }
      }
      
      return closestResult;
    }

    /**
     * Extract route shape coordinates between two points on the shape
     * If the points are on the same segment, returns a direct line
     * Otherwise returns the intermediate shape points
     */
    function extractShapeSegment(shapeCoords, startSegIdx, startT, endSegIdx, endT) {
      const coords = [];
      
      // Add start point
      const startSeg = shapeCoords[startSegIdx];
      const startSegEnd = shapeCoords[startSegIdx + 1];
      coords.push([
        startSeg[0] + startT * (startSegEnd[0] - startSeg[0]),
        startSeg[1] + startT * (startSegEnd[1] - startSeg[1])
      ]);
      
      // If backward movement (endSegIdx < startSegIdx), use direct line
      if (endSegIdx < startSegIdx) {
        const endSeg = shapeCoords[endSegIdx];
        const endSegEnd = shapeCoords[endSegIdx + 1];
        coords.push([
          endSeg[0] + endT * (endSegEnd[0] - endSeg[0]),
          endSeg[1] + endT * (endSegEnd[1] - endSeg[1])
        ]);
        return coords;
      }
      
      // If on same segment or adjacent, just add end point
      if (endSegIdx <= startSegIdx + 1) {
        const endSeg = shapeCoords[endSegIdx];
        const endSegEnd = shapeCoords[endSegIdx + 1];
        coords.push([
          endSeg[0] + endT * (endSegEnd[0] - endSeg[0]),
          endSeg[1] + endT * (endSegEnd[1] - endSeg[1])
        ]);
        return coords;
      }
      
      // Add intermediate shape points
      for (let i = startSegIdx + 1; i <= endSegIdx; i++) {
        coords.push(shapeCoords[i]);
      }
      
      // Add end point
      const endSeg = shapeCoords[endSegIdx];
      const endSegEnd = shapeCoords[endSegIdx + 1];
      coords.push([
        endSeg[0] + endT * (endSegEnd[0] - endSeg[0]),
        endSeg[1] + endT * (endSegEnd[1] - endSeg[1])
      ]);
      
      return coords;
    }

    function buildTrailsGeoJSON() {
      const features = [];
      const SNAP_THRESHOLD_DEGREES = 0.001; // ~100 meters at the equator
      
      for (const vehicleId in vehicleHistory) {
        const history = vehicleHistory[vehicleId];
        if (history.length < 2) continue; // Need at least 2 points for a line
        
        // Apply filter
        if (cachedFilterText) {
          const lastPos = history[history.length - 1];
          const matchesFilter = 
            (lastPos.route_id && lastPos.route_id.toLowerCase().includes(cachedFilterText)) ||
            (lastPos.label && lastPos.label.toLowerCase().includes(cachedFilterText));
          if (!matchesFilter) continue;
        }
        
        // Calculate average speed for the trail
        let avgSpeed = 0;
        let speedCount = 0;
        let speedSum = 0;
        
        // First try to use reported speeds if available
        for (let i = 0; i < history.length; i++) {
          const speed = history[i].speed;
          if (speed && speed > 0) {
            speedSum += speed;
            speedCount++;
          }
        }
        
        if (speedCount > 0) {
          avgSpeed = speedSum / speedCount;
        } else if (history.length >= 2) {
          // If no reported speeds, calculate from position changes
          let totalDistance = 0;
          let totalTime = 0;
          
          for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            const timeDiff = (curr.timestamp - prev.timestamp) / 1000; // seconds
            
            if (timeDiff > 0) {
              const dist = haversineDistance(
                prev.coords[1], prev.coords[0],
                curr.coords[1], curr.coords[0]
              );
              totalDistance += dist;
              totalTime += timeDiff;
            }
          }
          
          if (totalTime > 0) {
            avgSpeed = totalDistance / totalTime; // meters per second
          }
        }
        
        // Build coordinates, snapping to route shape when possible
        const coords = [];
        
        // Try to get shape for this vehicle's trip
        let shapeCoords = null;
        const lastPos = history[history.length - 1];
        if (lastPos.trip_id && tripToShape[lastPos.trip_id]) {
          const shapeId = tripToShape[lastPos.trip_id];
          if (allShapes[shapeId] && allShapes[shapeId].geometry) {
            shapeCoords = allShapes[shapeId].geometry.coordinates;
          }
        }
        
        for (let i = 0; i < history.length; i++) {
          const pos = history[i];
          
          if (i === 0) {
            // Always add first point
            coords.push(pos.coords);
          } else {
            const prevPos = history[i - 1];
            
            // Try to snap both points to the route shape
            if (shapeCoords && shapeCoords.length > 1) {
              const prevSnap = findClosestPointOnShape(prevPos.coords, shapeCoords);
              const currSnap = findClosestPointOnShape(pos.coords, shapeCoords);
              
              // Only snap if both points are close enough to the route (within threshold)
              const prevDistDegrees = prevSnap ? prevSnap.distance : Infinity;
              const currDistDegrees = currSnap ? currSnap.distance : Infinity;
              
              if (prevDistDegrees < SNAP_THRESHOLD_DEGREES && currDistDegrees < SNAP_THRESHOLD_DEGREES) {
                // Calculate how many shape segments we'd add
                const segmentCount = Math.abs(currSnap.segmentIndex - prevSnap.segmentIndex);
                
                // Only snap if segment count is reasonable (prevents adding hundreds of points for data gaps)
                if (segmentCount < 50) {
                  // Both points are on/near the route - extract the route segment between them
                  const segmentCoords = extractShapeSegment(
                    shapeCoords,
                    prevSnap.segmentIndex,
                    prevSnap.t,
                    currSnap.segmentIndex,
                    currSnap.t
                  );
                  
                  // Add all segment coords except the first (already added as previous point)
                  for (let j = 1; j < segmentCoords.length; j++) {
                    coords.push(segmentCoords[j]);
                  }
                } else {
                  // Too many intermediate points - just add direct line
                  coords.push(pos.coords);
                }
              } else {
                // One or both points are off-route - just add direct line
                coords.push(pos.coords);
              }
            } else {
              // No shape data available - just add direct line
              coords.push(pos.coords);
            }
          }
        }
        
        features.push({
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: coords
          },
          properties: {
            vehicle_id: vehicleId,
            speed: avgSpeed
          }
        });
      }
      
      return { type: 'FeatureCollection', features };
    }

    function calculateDistances(vehicleId) {
      const history = vehicleHistory[vehicleId];
      if (!history || history.length < 2) return [];
      
      const now = Date.now();
      const distances = [];
      const intervals = [10, 20, 30, 60, 120, 180, 300, 600]; // seconds
      
      for (const interval of intervals) {
        const targetTime = now - (interval * 1000);
        
        // Find the closest position in history to this time
        let closestPos = null;
        let minDiff = Infinity;
        
        for (const pos of history) {
          const diff = Math.abs(pos.timestamp - targetTime);
          if (diff < minDiff) {
            minDiff = diff;
            closestPos = pos;
          }
        }
        
        // Calculate distance if we found a position
        if (closestPos && minDiff < interval * 500) { // within half the interval
          const currentPos = history[history.length - 1];
          const distance = haversineDistance(
            closestPos.coords[1], closestPos.coords[0],
            currentPos.coords[1], currentPos.coords[0]
          );
          
          if (distance > 0) {
            const actualTimeDiff = (currentPos.timestamp - closestPos.timestamp) / 1000; // seconds
            const speedMps = actualTimeDiff > 0 ? distance / actualTimeDiff : 0; // m/s
            const speedKmh = Math.round(speedMps * 3.6); // convert to km/h
            distances.push({ 
              interval, 
              distance: Math.round(distance),
              speedKmh 
            });
          }
        }
      }
      
      return distances;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    /**
     * Parse GTFS time string (HH:MM:SS) to seconds since midnight
     * Handles times >= 24:00:00 (next day service)
     */
    function parseGtfsTime(timeStr) {
      if (!timeStr) return null;
      const parts = timeStr.split(':');
      if (parts.length !== 3) return null;
      const hours = parseInt(parts[0], 10);
      const minutes = parseInt(parts[1], 10);
      const seconds = parseInt(parts[2], 10);
      return hours * 3600 + minutes * 60 + seconds;
    }

    /**
     * Get current time in seconds since midnight (handles day wraparound)
     */
    function getCurrentTimeSeconds() {
      const now = new Date();
      return now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
    }

    /**
     * Calculate the delay in seconds for a vehicle based on scheduled vs actual position
     */
    function calculateVehicleDelay(stopTimes, currentStopSeq, vehicleTimestamp) {
      if (!stopTimes || !currentStopSeq || !vehicleTimestamp) return null;
      
      // Find the scheduled time for the current stop
      const currentStopTime = stopTimes.find(st => st.stop_sequence === currentStopSeq);
      if (!currentStopTime || !currentStopTime.arrival_time) return null;
      
      // arrival_time is now already in seconds (integer)
      const scheduledSeconds = currentStopTime.arrival_time;
      
      // Get actual time from vehicle timestamp
      const actualDate = new Date(Number(vehicleTimestamp) * 1000);
      const actualSeconds = actualDate.getHours() * 3600 + actualDate.getMinutes() * 60 + actualDate.getSeconds();
      
      // Calculate delay (positive = late, negative = early)
      // Handle day wraparound for late-night services
      let delay = actualSeconds - scheduledSeconds;
      if (delay > 12 * 3600) delay -= 24 * 3600; // Crossed midnight forward
      if (delay < -12 * 3600) delay += 24 * 3600; // Crossed midnight backward
      
      return delay;
    }

    // Calculate upcoming arrivals at a stop within the next 30 minutes
    function getUpcomingArrivals(stopId) {
      const arrivals = [];
      const now = Date.now();
      const thirtyMinutesFromNow = now + (30 * 60 * 1000);
      const currentTimeSeconds = getCurrentTimeSeconds();
      
      // Iterate through all current vehicles
      for (const feature of vehiclesGeoJSON.features) {
        const vehicleProps = feature.properties;
        const tripId = vehicleProps.trip_id;
        const currentStopSeq = vehicleProps.current_stop_sequence;
        const routeId = vehicleProps.route_id;
        const vehicleTimestamp = vehicleProps.timestamp;
        
        if (!tripId || !currentStopSeq) continue;
        
        // Get stop times for this trip
        const stopTimes = tripStopTimes[tripId];
        if (!stopTimes) continue;
        
        // Find the stop in this trip
        const stopTime = stopTimes.find(st => st.stop_id === stopId && st.stop_sequence >= currentStopSeq);
        if (!stopTime) continue;
        
        const stopsToGo = stopTime.stop_sequence - currentStopSeq;
        
        // Try to calculate ETA using scheduled times and current delay
        let estimatedMinutes = null;
        let estimatedArrival = null;
        
        if (stopTime.arrival_time && vehicleTimestamp) {
          // arrival_time is now already in seconds (integer)
          const scheduledArrivalSeconds = stopTime.arrival_time;
          
          // Calculate current delay
          const delay = calculateVehicleDelay(stopTimes, currentStopSeq, vehicleTimestamp);
          
          if (delay !== null) {
            // Apply delay to scheduled arrival time
            const estimatedArrivalSeconds = scheduledArrivalSeconds + delay;
            
            // Calculate time difference from now
            let secondsUntilArrival = estimatedArrivalSeconds - currentTimeSeconds;
            
            // Handle day wraparound
            if (secondsUntilArrival < -12 * 3600) secondsUntilArrival += 24 * 3600;
            if (secondsUntilArrival > 12 * 3600) secondsUntilArrival -= 24 * 3600;
            
            // Convert to milliseconds for arrival time
            estimatedArrival = now + (secondsUntilArrival * 1000);
            estimatedMinutes = secondsUntilArrival / 60;
          }
        }
        
        // Fallback to simple stop-counting method if scheduled data unavailable
        if (estimatedMinutes === null) {
          estimatedMinutes = stopsToGo * 2;
          estimatedArrival = now + (estimatedMinutes * 60 * 1000);
        }
        
        // Only include if within 30 minutes and not already passed
        if (estimatedArrival <= thirtyMinutesFromNow && estimatedMinutes >= 0) {
          arrivals.push({
            route_id: routeId,
            vehicle_label: vehicleProps.label,
            vehicle_id: vehicleProps.id,
            eta_minutes: Math.round(estimatedMinutes),
            stops_away: stopsToGo
          });
        }
      }
      
      // Sort by ETA
      arrivals.sort((a, b) => a.eta_minutes - b.eta_minutes);
      return arrivals;
    }

    // Build stops GeoJSON based on current filters
    function buildStopsGeoJSON() {
      const features = [];
      
      // Determine which stops to show based on route filter
      let stopIdsToShow = new Set();
      
      if (cachedFilterText) {
        // Show stops for filtered routes
        for (const rid in routeStops) {
          if (rid.toLowerCase().includes(cachedFilterText)) {
            routeStops[rid].forEach(stopId => stopIdsToShow.add(stopId));
          }
        }
      } else {
        // Show stops for routes that have active vehicles
        const filteredVehicles = applyFilter(vehiclesGeoJSON);
        filteredVehicles.features.forEach(f => {
          const routeId = f.properties.route_id;
          if (routeId && routeStops[routeId]) {
            routeStops[routeId].forEach(stopId => stopIdsToShow.add(stopId));
          }
        });
      }
      
      // Create features for each stop
      for (const stopId of stopIdsToShow) {
        const stop = allStops[stopId];
        if (stop) {
          features.push({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [stop.lon, stop.lat]
            },
            properties: {
              stop_id: stopId,
              stop_name: stop.name
            }
          });
        }
      }
      
      return { type: 'FeatureCollection', features };
    }

    // Linear interpolation between two coordinates
    function lerpCoordinates(from, to, t) {
      return [
        from[0] + (to[0] - from[0]) * t,
        from[1] + (to[1] - from[1]) * t
      ];
    }

    // Animation frame function
    function animatePositions(timestamp) {
      if (!animationStartTime) {
        animationStartTime = timestamp;
      }

      const elapsed = timestamp - animationStartTime;
      const progress = Math.min(elapsed / ANIMATION_DURATION_MS, 1);
      
      // Use easing function for smoother animation (ease-in-out)
      const eased = progress < 0.5
        ? 2 * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

      // Create interpolated GeoJSON - minimize object allocations
      const interpolatedFeatures = new Array(vehiclesGeoJSON.features.length);
      for (let i = 0; i < vehiclesGeoJSON.features.length; i++) {
        const feature = vehiclesGeoJSON.features[i];
        const vehicleId = feature.properties.id;
        if (vehicleId && previousPositions[vehicleId] && targetPositions[vehicleId]) {
          const interpolatedCoords = lerpCoordinates(
            previousPositions[vehicleId],
            targetPositions[vehicleId],
            eased
          );
          // Create new feature with interpolated coordinates
          interpolatedFeatures[i] = {
            type: feature.type,
            id: feature.id,
            geometry: {
              type: feature.geometry.type,
              coordinates: interpolatedCoords
            },
            properties: feature.properties
          };
        } else {
          interpolatedFeatures[i] = feature;
        }
      }

      const interpolatedGeoJSON = {
        type: 'FeatureCollection',
        features: interpolatedFeatures
      };

      // Update map with interpolated positions
      const filteredVehicles = applyFilter(interpolatedGeoJSON);
      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
      }

      // Continue animation or finish
      if (progress < 1) {
        requestAnimationFrame(animatePositions);
      } else {
        animationInProgress = false;
        animationStartTime = null;
      }
    }

    // Start position animation
    function startPositionAnimation(newGeoJSON) {
      // Store previous positions
      if (vehiclesGeoJSON.features.length > 0) {
        vehiclesGeoJSON.features.forEach(feature => {
          const vehicleId = feature.properties.id;
          if (vehicleId) {
            previousPositions[vehicleId] = feature.geometry.coordinates;
          }
        });
      }

      // Store target positions from new data
      newGeoJSON.features.forEach(feature => {
        const vehicleId = feature.properties.id;
        if (vehicleId) {
          targetPositions[vehicleId] = feature.geometry.coordinates;
          // If this is a new vehicle, set previous position to current to avoid animation from 0,0
          if (!previousPositions[vehicleId]) {
            previousPositions[vehicleId] = feature.geometry.coordinates;
          }
        }
      });

      // Update vehiclesGeoJSON reference
      vehiclesGeoJSON = newGeoJSON;

      // Start animation if not already running
      if (!animationInProgress) {
        animationInProgress = true;
        animationStartTime = null;
        requestAnimationFrame(animatePositions);
      }
    }

    function formatInterval(seconds) {
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      if (secs === 0) return `${minutes}m`;
      return `${minutes}m ${secs}s`;
    }

    // Update trails and routes only (not vehicle positions - those are animated separately)
    function updateMapSourceNonAnimated() {
      const trailsGeoJSON = buildTrailsGeoJSON();

      // --- Filter shapes based on filter text ---
      let routeIds = new Set();
      if (cachedFilterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(cachedFilterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        const filteredVehicles = applyFilter(vehiclesGeoJSON);
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      
      // Only build shape features if routes are enabled
      const shapeFeatures = showRoutes ? (function() {
        const features = [];
        for (const rid of routeIds) {
          const sids = routeToShapes[rid];
          if (!sids) continue;
          for (const sid of sids) {
            if (allShapes[sid]) features.push(allShapes[sid]);
          }
        }
        return features;
      })() : [];

      // Build stops - only show when routes are enabled
      const stopsGeoJSON = showRoutes ? buildStopsGeoJSON() : {type:"FeatureCollection",features:[]};

      if (map.getSource('vehicle-trails')) {
        map.getSource('vehicle-trails').setData(trailsGeoJSON);
      }
      if (map.getSource('routes')) {
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
      }
      if (map.getSource('stops')) {
        map.getSource('stops').setData(stopsGeoJSON);
      }
    }

    function updateMapSource() {
      const filteredVehicles = applyFilter(vehiclesGeoJSON);
      const trailsGeoJSON = buildTrailsGeoJSON();

      // --- Filter shapes based on filter text ---
      let routeIds = new Set();
      if (cachedFilterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(cachedFilterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      
      // Only build shape features if routes are enabled
      const shapeFeatures = showRoutes ? (function() {
        const features = [];
        for (const rid of routeIds) {
          const sids = routeToShapes[rid];
          if (!sids) continue;
          for (const sid of sids) {
            if (allShapes[sid]) features.push(allShapes[sid]);
          }
        }
        return features;
      })() : [];

      // Build stops - only show when routes are enabled
      const stopsGeoJSON = showRoutes ? buildStopsGeoJSON() : {type:"FeatureCollection",features:[]};

      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
        map.getSource('vehicle-trails').setData(trailsGeoJSON);
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
        map.getSource('stops').setData(stopsGeoJSON);
      } else {
        map.addSource('vehicles', { 
          type: 'geojson', 
          data: filteredVehicles,
          generateId: false  // Use feature IDs from GeoJSON
        });
        map.addLayer({
          id: 'vehicle-circles',
          type: 'circle',
          source: 'vehicles',
          paint: {
            'circle-radius': 5,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#fff',
            'circle-radius-transition': { duration: 2000 },
            'circle-opacity-transition': { duration: 2000 }
          }
        });
        map.addLayer({
          id: 'vehicle-labels',
          type: 'symbol',
          source: 'vehicles',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ['get', 'route_id'], ''],
            'text-size': 12,
            'text-offset': [0, 1.3]
          }
        });
        map.on('click', 'vehicle-circles', (e) => {
          const vehicle = e.features[0];
          const props = vehicle.properties;
          
          // Set the route filter to the clicked vehicle's route
          if (props.route_id) {
            const routeNumber = props.route_id.split('-')[0];
            routeFilterEl.value = routeNumber;
            cachedFilterText = routeNumber.toLowerCase();
            updateClearButton();
            updateMapSource();
          }
          
          // Show popup with follow button
          showVehiclePopup(vehicle, e.lngLat);
        });
        map.on('mouseenter', 'vehicle-circles', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vehicle-circles', () => map.getCanvas().style.cursor = '');

        map.addSource('vehicle-trails', { type: 'geojson', data: trailsGeoJSON });
        map.addLayer({
          id: 'vehicle-trails-lines',
          type: 'line',
          source: 'vehicle-trails',
          paint: {
            'line-width': 2,
            'line-color': [
              'interpolate',
              ['linear'],
              ['get', 'speed'],
              0, '#888888',      // Stationary: grey
              5, '#F44336',      // Slow: red (5 m/s ≈ 18 km/h)
              10, '#FF9800',     // Medium: orange (10 m/s ≈ 36 km/h)
              15, '#FFC107',     // Fast: amber (15 m/s ≈ 54 km/h)
              20, '#4CAF50'      // Very fast: green (20 m/s ≈ 72 km/h)
            ],
            'line-opacity': 0.6
          }
        }, 'vehicle-circles'); // Add trails below vehicle circles
        map.getSource("routes").setData({type:"FeatureCollection",features:shapeFeatures});
        map.getSource("stops").setData(stopsGeoJSON);

        // Add click handler for stops
        map.on('click', 'stop-circles', (e) => {
          const props = e.features[0].properties;
          const stopId = props.stop_id;
          const stopName = props.stop_name;
          
          // Get upcoming arrivals
          const arrivals = getUpcomingArrivals(stopId);
          
          // Create popup HTML
          let html = `<div style="font-family: inherit; min-width: 200px; max-width: 280px; padding: 4px;">`;
          html += `<div style="font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #FF5722;">${stopName}</div>`;
          
          // Stop details
          html += `<div style="font-size: 13px; line-height: 1.6; color: #555;">`;
          html += `<div style="margin-bottom: 8px;"><span style="color: #888;">Stop ID:</span> <strong>${stopId}</strong></div>`;
          
          // Upcoming arrivals
          if (arrivals.length > 0) {
            html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
            html += `<div style="font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 6px;">Next arrivals (30min):</div>`;
            html += '<div style="font-size: 12px; color: #666; line-height: 1.8; max-height: 300px; overflow-y: auto;">';
            for (const arrival of arrivals) {
              const etaText = arrival.eta_minutes < 1 ? 'Now' : `${arrival.eta_minutes} min`;
              const routeLabel = arrival.vehicle_label || arrival.route_id;
              // Color scheme: Red (imminent) -> Yellow (medium) -> Green (comfortable)
              let etaColor;
              if (arrival.eta_minutes < 1) {
                etaColor = '#F44336'; // Red - arriving now
              } else if (arrival.eta_minutes <= 5) {
                etaColor = '#F44336'; // Red - arriving very soon (0-5 min)
              } else if (arrival.eta_minutes <= 10) {
                etaColor = '#FF9800'; // Orange - arriving soon (5-10 min)
              } else if (arrival.eta_minutes <= 15) {
                etaColor = '#FFC107'; // Amber - medium time (10-15 min)
              } else {
                etaColor = '#4CAF50'; // Green - comfortable time (15+ min)
              }
              html += `<div style="margin-bottom: 4px; padding: 4px; background: #f5f5f5; border-radius: 4px;">`;
              html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
              html += `<span style="font-weight: 600; color: #0077cc;">${routeLabel}</span>`;
              html += `<span style="color: ${etaColor}; font-weight: 600;">${etaText}</span>`;
              html += `</div>`;
              html += `<div style="font-size: 11px; color: #888; margin-top: 2px;">${arrival.stops_away} ${arrival.stops_away === 1 ? 'stop' : 'stops'} away</div>`;
              html += `</div>`;
            }
            html += '</div></div>';
          } else {
            html += `<div style="margin-top: 8px; padding: 8px; background: #f5f5f5; border-radius: 4px; color: #888; font-size: 12px; text-align: center;">No arrivals in next 30 minutes</div>`;
          }
          
          html += `</div></div>`;
          new maplibregl.Popup({
            maxWidth: '300px',
            className: 'custom-popup'
          }).setLngLat(e.lngLat).setHTML(html).addTo(map);
        });
        map.on('mouseenter', 'stop-circles', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'stop-circles', () => map.getCanvas().style.cursor = '');
      }
    }

    // Slideshow and follow mode functions
    function getRandomVehicle() {
      const vehicles = vehiclesGeoJSON.features;
      if (vehicles.length === 0) return null;
      const randomIndex = Math.floor(Math.random() * vehicles.length);
      return vehicles[randomIndex];
    }

    function stopFollowMode() {
      followModeActive = false;
      currentFollowedVehicle = null;
      if (rotationAnimationId) {
        cancelAnimationFrame(rotationAnimationId);
        rotationAnimationId = null;
      }
      currentRotationAngle = 0;
      rotationStartTime = null;
      
      // Close popup if it exists
      if (currentFollowPopup) {
        currentFollowPopup.remove();
        currentFollowPopup = null;
      }
      
      // Hide follow indicator
      followIndicator.classList.remove('visible');
      
      // Reset camera to default view when stopping follow mode
      map.easeTo({
        pitch: 0,
        bearing: 0,
        duration: 1000
      });
    }

    function stopSlideshow() {
      slideshowActive = false;
      slideshowBtn.classList.remove('active');
      if (slideshowTimer) {
        clearTimeout(slideshowTimer);
        slideshowTimer = null;
      }
      stopFollowMode();
      logDebug('Slideshow stopped', 'info');
    }

    function followVehicle(vehicleId, coords, showPopup = false, autoAdvance = false) {
      stopFollowMode(); // Stop any existing follow mode
      
      currentFollowedVehicle = vehicleId;
      followModeActive = true;
      currentRotationAngle = 0;
      
      // Get vehicle info for display
      const vehicle = vehiclesGeoJSON.features.find(f => f.properties.id === vehicleId);
      const vehicleLabel = vehicle ? (vehicle.properties.label || vehicle.properties.route_id || 'Vehicle') : 'Vehicle';
      
      // Show follow indicator
      if (autoAdvance) {
        followIndicatorText.textContent = `🎬 Slideshow: Following ${vehicleLabel} (Press ESC to stop)`;
      } else {
        followIndicatorText.textContent = `📹 Following ${vehicleLabel} (Press ESC or click map to stop)`;
      }
      followIndicator.classList.add('visible');
      
      // Fly to vehicle with animation
      map.flyTo({
        center: coords,
        zoom: 16, // Closer zoom for better detail
        pitch: 60, // Isometric-like view
        bearing: 0,
        duration: 2000,
        essential: true
      });
      
      // Wait for flyTo to complete before starting rotation animation
      // This prevents the rotation from interrupting the flyTo animation
      setTimeout(() => {
        if (!followModeActive) return; // Check if mode was cancelled during flyTo
        
        // Don't show popup automatically - user can toggle it if needed
        
        // Start rotation animation using requestAnimationFrame for smooth rotation
        rotationStartTime = performance.now();
        let lastKnownCoords = null;
        
        function animateRotation(currentTime) {
          if (!followModeActive) {
            return;
          }
          
          // Calculate elapsed time since rotation started
          const elapsedSeconds = (currentTime - rotationStartTime) / 1000;
          
          // Calculate current angle based on elapsed time and rotation speed
          currentRotationAngle = (ROTATION_SPEED * elapsedSeconds) % 360;
          
          // Update camera bearing smoothly
          map.setBearing(currentRotationAngle);
          
          // Keep camera centered on vehicle (it may have moved)
          const vehicle = vehiclesGeoJSON.features.find(f => f.properties.id === vehicleId);
          if (vehicle) {
            const newCoords = vehicle.geometry.coordinates;
            
            // Only fly to new position if coordinates have changed
            if (!lastKnownCoords || 
                lastKnownCoords[0] !== newCoords[0] || 
                lastKnownCoords[1] !== newCoords[1]) {
              // Use flyTo with 2 second duration for smooth transitions
              map.flyTo({
                center: newCoords,
                duration: 2000, // 2 seconds for smooth animation
                essential: false
              });
              lastKnownCoords = newCoords.slice(); // Store a copy
            }
            
            // Update popup position if it exists
            if (currentFollowPopup && currentFollowPopup.isOpen()) {
              currentFollowPopup.setLngLat(newCoords);
            }
          }
          
          // Continue animation loop
          rotationAnimationId = requestAnimationFrame(animateRotation);
        }
        
        // Start the animation loop
        rotationAnimationId = requestAnimationFrame(animateRotation);
      }, 2100); // Wait for flyTo duration (2000ms) + small buffer
      
      // Set up auto-advance if in slideshow mode
      if (autoAdvance) {
        slideshowTimer = setTimeout(() => {
          if (slideshowActive) {
            startSlideshow(); // Move to next random vehicle
          }
        }, SLIDESHOW_DURATION_MS);
      }
    }

    function showVehiclePopup(vehicle, coords) {
      const props = vehicle.properties;
      const vehicleId = props.id;
      
      // Create popup HTML with follow button
      let html = `<div style="font-family: inherit; min-width: 200px; max-width: 280px; padding: 4px;">`;
      html += `<div style="font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #0077cc; word-wrap: break-word;">${props.label || props.route_id || 'Vehicle'}</div>`;
      
      // Vehicle details
      html += `<div style="font-size: 13px; line-height: 1.6; color: #555;">`;
      if (props.human_readable_id) {
        html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Human-readable ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.human_readable_id}</strong></div>`;
      }
      html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Trip ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.trip_id || '—'}</strong></div>`;
      html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Vehicle ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.id || '—'}</strong></div>`;
      
      // Last seen time
      if (props.timestamp) {
        const lastSeenTime = new Date(Number(props.timestamp) * 1000);
        const timeStr = lastSeenTime.toLocaleTimeString();
        html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Last seen:</span> <strong>${timeStr}</strong></div>`;
      }
      
      // Add current speed if available
      if (vehicleId && vehicleHistory[vehicleId] && vehicleHistory[vehicleId].length >= 2) {
        const history = vehicleHistory[vehicleId];
        const lastPos = history[history.length - 1];
        const prevPos = history[history.length - 2];
        const timeDiff = (lastPos.timestamp - prevPos.timestamp) / 1000;
        
        if (timeDiff > 0) {
          const distance = haversineDistance(
            prevPos.coords[1], prevPos.coords[0],
            lastPos.coords[1], lastPos.coords[0]
          );
          const speedMps = distance / timeDiff;
          const speedKmh = Math.round(speedMps * 3.6);
          html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Current speed:</span> <strong style="color: #0077cc;">${speedKmh} km/h</strong></div>`;
        }
      }
      html += `</div>`;
      
      // Add distance history if available
      if (vehicleId && vehicleHistory[vehicleId]) {
        const distances = calculateDistances(vehicleId);
        if (distances.length > 0) {
          html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
          html += `<div style="font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 6px;">Distance traveled:</div>`;
          html += '<div style="font-size: 12px; color: #666; line-height: 1.8;">';
          for (const d of distances) {
            const avgSpeed = d.speedKmh;
            const speedColor = avgSpeed > 40 ? '#4CAF50' : avgSpeed > 20 ? '#FFC107' : '#888';
            html += `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;">`;
            html += `<span>${formatInterval(d.interval)}:</span>`;
            html += `<span><strong>${d.distance}m</strong> <span style="color: ${speedColor};">(${d.speedKmh} km/h)</span></span>`;
            html += `</div>`;
          }
          html += '</div></div>';
        }
      }
      
      // Add follow button
      html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
      html += `<button id="followBtn" style="width: 100%; padding: 8px 12px; background: linear-gradient(to bottom, #0077cc, #0066b3); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; transition: background 0.2s;">📹 Follow this vehicle</button>`;
      html += `</div>`;
      
      html += '</div>';
      
      const popup = new maplibregl.Popup({
        maxWidth: '300px',
        className: 'custom-popup'
      }).setLngLat(coords).setHTML(html).addTo(map);
      
      // Add event listener for follow button after popup is added to DOM
      setTimeout(() => {
        const followBtn = document.getElementById('followBtn');
        if (followBtn) {
          followBtn.addEventListener('click', () => {
            stopSlideshow(); // Stop slideshow if active
            popup.remove(); // Close popup
            followVehicle(vehicleId, coords, false, false);
            logDebug(`Started follow mode for vehicle ${vehicleId}`, 'info');
          });
          
          // Add hover effect
          followBtn.addEventListener('mouseenter', () => {
            followBtn.style.background = 'linear-gradient(to bottom, #0066b3, #00558a)';
          });
          followBtn.addEventListener('mouseleave', () => {
            followBtn.style.background = 'linear-gradient(to bottom, #0077cc, #0066b3)';
          });
        }
      }, 100);
      
      return popup;
    }

    function startSlideshow() {
      const vehicle = getRandomVehicle();
      if (!vehicle) {
        logDebug('No vehicles available for slideshow', 'warn');
        stopSlideshow();
        return;
      }
      
      const vehicleId = vehicle.properties.id;
      const coords = vehicle.geometry.coordinates;
      
      logDebug(`Slideshow: Following vehicle ${vehicleId} (${vehicle.properties.label || vehicle.properties.route_id})`, 'info');
      followVehicle(vehicleId, coords, false, true);
    }

    refreshBtn.addEventListener('click', () => fetchFeedAndUpdate());
    
    // Show/hide clear button based on input value
    function updateClearButton() {
      if (routeFilterEl.value.trim()) {
        clearBtn.classList.add('visible');
      } else {
        clearBtn.classList.remove('visible');
      }
    }
    
    routeFilterEl.addEventListener('input', () => {
      updateClearButton();
      cachedFilterText = routeFilterEl.value.trim().toLowerCase();
      updateMapSource();
    });
    
    clearBtn.addEventListener('click', () => {
      routeFilterEl.value = '';
      cachedFilterText = '';
      updateClearButton();
      updateMapSource();
      routeFilterEl.focus();
    });
    
    autoRefreshBtn.addEventListener('click', () => { 
      autoRefreshBtn.classList.toggle('active');
      if (autoRefreshBtn.classList.contains('active')) {
        startAutoRefresh();
      } else {
        stopAutoRefresh();
      }
    });
    locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) return alert('Geolocation not available');
      navigator.geolocation.getCurrentPosition(pos => {
        const coords = [pos.coords.longitude, pos.coords.latitude];
        userLocation.features = [{
          type: 'Feature',
          geometry: { type: 'Point', coordinates: coords }
        }];
        map.getSource('user-location').setData(userLocation);
        map.flyTo({ center: coords, zoom: 14 });
      }, e => alert('Unable to get location: ' + e.message));
    });
    
    toggleRoutesBtn.addEventListener('click', () => {
      toggleRoutesBtn.classList.toggle('active');
      showRoutes = toggleRoutesBtn.classList.contains('active');
      updateMapSource();
    });
    
    slideshowBtn.addEventListener('click', () => {
      slideshowBtn.classList.toggle('active');
      if (slideshowBtn.classList.contains('active')) {
        slideshowActive = true;
        logDebug('Slideshow started', 'info');
        startSlideshow();
      } else {
        stopSlideshow();
      }
    });
    
    // Add keyboard support for exiting follow/slideshow mode and clearing filter
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (followModeActive || slideshowActive) {
          stopSlideshow();
          logDebug('Follow/slideshow mode stopped via Escape key', 'info');
        } else if (routeFilterEl.value.trim()) {
          // Clear the route filter
          routeFilterEl.value = '';
          cachedFilterText = '';
          updateClearButton();
          updateMapSource();
          logDebug('Route filter cleared via Escape key', 'info');
        }
      }
    });
    
    // Allow clicking on map background to exit follow mode (but not slideshow) and clear filter
    map.on('click', (e) => {
      // Only exit follow mode if clicking on empty space (not on a vehicle or stop)
      const features = map.queryRenderedFeatures(e.point, {
        layers: ['vehicle-circles', 'stop-circles']
      });
      
      if (features.length === 0) {
        if (followModeActive && !slideshowActive) {
          stopFollowMode();
          logDebug('Follow mode stopped via map click', 'info');
        } else if (routeFilterEl.value.trim()) {
          // Clear the route filter
          routeFilterEl.value = '';
          cachedFilterText = '';
          updateClearButton();
          updateMapSource();
          logDebug('Route filter cleared via map click', 'info');
        }
      }
    });

    function startAutoRefresh() {
      stopAutoRefresh();
      autoTimer = setInterval(fetchFeedAndUpdate, REFRESH_INTERVAL_MS);
    }
    function stopAutoRefresh() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }

    (async function(){
      try {
        updateStatus('Loading protocol definitions...');
        await loadProto();
        updateStatus('Waiting for map to load...');
        
        // Handle map initialization (may already be loaded or still loading)
        const initializeApp = async () => {
          try {
            logDebug('Map loaded successfully', 'info');
            await loadGTFS();
            updateStatus('Fetching initial vehicle data...');
            await fetchFeedAndUpdate();
            updateStatus('Starting auto-refresh...');
            startAutoRefresh();
            logDebug('Application initialized successfully', 'info');
            updateStatus('Ready! All systems operational.');
            // Hide status bar after 2 seconds
            setTimeout(() => {
              hideStatusBar();
            }, 2000);
          } catch (err) {
            logDebug('Error during map initialization: ' + err.message, 'error');
            updateStatus('Error during initialization');
            alert('Failed to load map data: ' + err.message);
          }
        };
        
        // Check if map is already loaded or wait for it
        if (map.loaded()) {
          logDebug('Map already loaded, initializing immediately', 'info');
          await initializeApp();
        } else {
          map.on('load', initializeApp);
        }
      } catch (err) {
        logDebug('Startup error: ' + err.message, 'error');
        updateStatus('Startup error');
        alert('Failed to initialise: ' + err.message);
      }
    })();
  </script>
</body>
</html>
