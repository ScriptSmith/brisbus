<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="description" content="Live Brisbane bus tracking map using GTFS real-time data" />
  <meta name="theme-color" content="#0077cc" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Brisbane Buses" />
  <title>Brisbane Buses ‚Äî Live Map (GTFS)</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    
    .ui { 
      position: absolute; 
      left: 12px; 
      top: 12px; 
      right: 12px;
      z-index: 2; 
      background: rgba(255,255,255,0.97); 
      padding: 14px 16px; 
      border-radius: 12px; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
      max-width: 420px;
      backdrop-filter: blur(10px);
    }
    
    .ui h1 { 
      margin: 0 0 12px 0; 
      font-size: 18px; 
      font-weight: 600;
      color: #1a1a1a;
      letter-spacing: -0.01em;
    }
    
    .controls { 
      display: flex; 
      gap: 10px; 
      align-items: stretch; 
      flex-wrap: wrap; 
    }
    
    .controls input[type=text] { 
      flex: 1; 
      min-width: 180px; 
      padding: 11px 14px; 
      border-radius: 8px; 
      border: 1.5px solid #ddd; 
      font-size: 15px;
      background: #fff;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    
    .controls input[type=text]:focus { 
      outline: none;
      border-color: #0077cc;
      box-shadow: 0 0 0 3px rgba(0, 119, 204, 0.1);
    }
    
    button { 
      padding: 11px 18px; 
      border-radius: 8px; 
      border: 1.5px solid #d0d0d0; 
      background: linear-gradient(to bottom, #fff, #f8f8f8); 
      cursor: pointer; 
      font-size: 15px;
      font-weight: 500;
      color: #333;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.15s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      white-space: nowrap;
    }
    
    button:hover { 
      background: linear-gradient(to bottom, #f8f8f8, #f0f0f0);
      border-color: #b8b8b8;
      box-shadow: 0 2px 4px rgba(0,0,0,0.12);
    }
    
    button:active { 
      background: #e8e8e8;
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }
    
    .toggle-btn.active {
      background: linear-gradient(to bottom, #0077cc, #0066b3);
      border-color: #0055aa;
      color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    
    .toggle-btn.active:hover {
      background: linear-gradient(to bottom, #0066b3, #005599);
      border-color: #004488;
    }
    
    .controls-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .controls-row label {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      cursor: pointer;
      user-select: none;
      font-size: 15px;
      color: #333;
      padding: 4px 0;
    }
    
    .controls-row input[type=checkbox] {
      cursor: pointer;
      width: 18px;
      height: 18px;
      margin: 0;
    }
    
    .meta { 
      margin-top: 12px; 
      padding-top: 12px;
      border-top: 1px solid #e8e8e8;
      font-size: 14px; 
      color: #555;
      line-height: 1.6;
    }
    
    .meta div {
      margin-bottom: 4px;
    }
    
    .meta span {
      font-weight: 500;
      color: #1a1a1a;
    }
    
    .legend { 
      margin-top: 10px; 
      padding-top: 10px;
      border-top: 1px solid #e8e8e8;
      font-size: 12px; 
      color: #777; 
      line-height: 1.5; 
    }
    
    /* Custom popup styling */
    .maplibregl-popup-content {
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      padding: 12px 14px;
    }
    
    .maplibregl-popup-close-button {
      font-size: 20px;
      padding: 4px 8px;
      color: #888;
    }
    
    .maplibregl-popup-close-button:hover {
      background: #f0f0f0;
      color: #333;
    }
    
    /* Mobile responsive styles */
    @media (max-width: 768px) {
      .ui {
        left: 10px;
        right: 10px;
        top: 10px;
        padding: 10px;
        max-width: none;
      }
      
      .ui h1 {
        font-size: 16px;
        margin-bottom: 8px;
      }
      
      /* Combine all controls into a single row */
      .controls,
      .controls-row {
        display: inline-flex;
        gap: 6px;
        flex-wrap: nowrap;
        margin-top: 0;
      }
      
      .controls input[type=text] {
        flex: 1;
        min-width: 0;
        padding: 10px;
        font-size: 16px; /* Prevent zoom on iOS */
      }
      
      button {
        padding: 10px 12px;
        font-size: 14px;
        white-space: nowrap;
      }
      
      .controls-row label {
        font-size: 14px;
        white-space: nowrap;
      }
      
      .meta {
        margin-top: 8px;
        padding-top: 8px;
        font-size: 13px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      
      .meta div {
        margin-bottom: 0;
        white-space: nowrap;
      }
      
      .legend {
        display: none; /* Hide on mobile */
      }
    }
    
    @media (max-width: 640px) {
      .ui {
        padding: 8px;
      }
      
      .ui h1 { 
        font-size: 15px; 
        margin-bottom: 6px;
      }
      
      .controls,
      .controls-row { 
        gap: 4px;
        flex-wrap: nowrap;
        margin-top: 0;
      }
      
      .controls input[type=text] { 
        padding: 9px 8px;
      }
      
      button { 
        padding: 9px 10px; 
        font-size: 13px;
      }
      
      .meta { 
        font-size: 12px; 
        margin-top: 6px;
        padding-top: 6px;
      }
    }
    
    @media (max-width: 400px) {
      .ui {
        left: 8px;
        right: 8px;
        top: 8px;
        padding: 6px;
      }
      
      .ui h1 {
        font-size: 14px;
        margin-bottom: 4px;
      }
      
      .controls,
      .controls-row { 
        gap: 3px;
        flex-wrap: nowrap;
        margin-top: 0;
      }
      
      .controls input[type=text] { 
        padding: 8px 6px;
        font-size: 16px;
      }
      
      button {
        padding: 8px 8px;
        font-size: 12px;
      }
      
      .controls-row label {
        font-size: 12px;
      }
      
      .meta {
        font-size: 11px;
        margin-top: 4px;
        padding-top: 4px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="ui">
    <h1>Brisbane buses ‚Äî Live</h1>
    <div class="controls">
      <input id="routeFilter" type="text" placeholder="Filter by route number" />
      <button id="refreshBtn" title="Refresh">üîÑ</button>
    </div>
    <div class="controls-row">
      <button id="autoRefreshBtn" class="toggle-btn active" title="Auto-refresh (10s)">‚è±Ô∏è</button>
      <button id="locateBtn" title="My location">üìç</button>
    </div>
    <div class="meta">
      <div>Current time: <span id="currentTime">‚Äî</span></div>
      <div>Last update: <span id="lastUpdate">‚Äî</span></div>
      <div>Vehicles shown: <span id="count">0</span></div>
    </div>
    <div class="legend">Source: Translink GTFS &amp; GTFS-RT (proxied) ‚Äî Carto basemap</div>
  </div>

  <script src="https://unpkg.com/protobufjs@7.2.3/dist/protobuf.min.js"></script>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script>
    const PROXY_FEED_URL = 'https://api.codetabs.com/v1/proxy?quest=https://gtfsrt.api.translink.com.au/api/realtime/SEQ/VehiclePositions';
    // Support both GitHub Pages (/brisbus/) and local dev
    const GTFS_BASE_URL = window.location.pathname.includes('/brisbus/') ? '/brisbus/data/' : '/data/';
    const PROTO_URL = 'https://raw.githubusercontent.com/google/transit/master/gtfs-realtime/proto/gtfs-realtime.proto';
    const REFRESH_INTERVAL_MS = 10000;
    const HISTORY_WINDOW_MS = 10 * 60 * 1000; // 10 minutes for trails

    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [153.0251, -27.4679],
      zoom: 11
    });
    map.addControl(new maplibregl.NavigationControl({showCompass: false}), 'top-right');

    let root = null, feedMessageType = null;
    let vehiclesGeoJSON = { type: 'FeatureCollection', features: [] };
    let vehicleHistory = {}; // vehicle_id ‚Üí array of {coords, timestamp, speed}
    let allShapes = {};      // shape_id ‚Üí Feature
    let routeToShapes = {};  // route_id ‚Üí Set(shape_id)
    let autoTimer = null;
    let userLocation = { type: 'FeatureCollection', features: [] };

    const lastUpdateEl = document.getElementById('lastUpdate');
    const countEl = document.getElementById('count');
    const currentTimeEl = document.getElementById('currentTime');
    const refreshBtn = document.getElementById('refreshBtn');
    const autoRefreshBtn = document.getElementById('autoRefreshBtn');
    const routeFilterEl = document.getElementById('routeFilter');
    const locateBtn = document.getElementById('locateBtn');

    // Update current time every second
    function updateCurrentTime() {
      const now = new Date();
      currentTimeEl.textContent = now.toLocaleTimeString();
    }
    updateCurrentTime();
    setInterval(updateCurrentTime, 1000);

    async function loadProto() {
      const res = await fetch(PROTO_URL);
      const protoText = await res.text();
      const parsed = protobuf.parse(protoText);
      root = parsed.root;
      feedMessageType = root.lookupType('transit_realtime.FeedMessage');
    }

    /**
     * Fetch and decompress a GTFS file
     * Uses brotli for WebKit browsers, gzip for everything else
     * WebKit has better brotli support via DecompressionStream
     */
    async function fetchAndDecompress(filename) {
      // Detect if we should use brotli (WebKit/Safari) or gzip (everything else)
      const isWebKit = /WebKit/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
      const useBrotli = isWebKit;
      
      if (useBrotli) {
        // Fetch and decompress brotli file for WebKit
        console.log(`Fetching ${filename}.br...`);
        const res = await fetch(`${GTFS_BASE_URL}${filename}.br`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        // Use DecompressionStream to decompress brotli data
        const ds = new DecompressionStream('brotli');
        const decompressedStream = res.body.pipeThrough(ds);
        const decompressed = await new Response(decompressedStream).arrayBuffer();
        const text = new TextDecoder().decode(decompressed);
        
        console.log(`Successfully loaded and decompressed ${filename}.br`);
        return text;
      } else {
        // Fetch and decompress gzip file for other browsers
        console.log(`Fetching ${filename}.gz...`);
        const res = await fetch(`${GTFS_BASE_URL}${filename}.gz`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        // Use DecompressionStream to decompress gzip data
        const ds = new DecompressionStream('gzip');
        const decompressedStream = res.body.pipeThrough(ds);
        const decompressed = await new Response(decompressedStream).arrayBuffer();
        const text = new TextDecoder().decode(decompressed);
        
        console.log(`Successfully loaded and decompressed ${filename}.gz`);
        return text;
      }
    }

    async function loadGTFS() {
      console.log('Loading GTFS data...');
      
      // Fetch compressed files
      const shapesTxt = await fetchAndDecompress('shapes.txt');
      const tripsTxt = await fetchAndDecompress('trips.txt');

      // --- Parse shapes.txt ---
      const lines = shapesTxt.trim().split(/\r?\n/);
      const headers = lines.shift().split(",");
      const idx = Object.fromEntries(headers.map((h,i)=>[h,i]));
      const tmp = {};
      for (const line of lines) {
        const parts = line.split(",");
        const sid = parts[idx["shape_id"]];
        const lat = parseFloat(parts[idx["shape_pt_lat"]]);
        const lon = parseFloat(parts[idx["shape_pt_lon"]]);
        const seq = parseInt(parts[idx["shape_pt_sequence"]],10);
        if (!tmp[sid]) tmp[sid] = [];
        tmp[sid].push({seq, coord:[lon,lat]});
      }
      for (const sid in tmp) {
        tmp[sid].sort((a,b)=>a.seq-b.seq);
        allShapes[sid] = {
          type:"Feature",
          geometry:{type:"LineString", coordinates:tmp[sid].map(p=>p.coord)},
          properties:{shape_id:sid}
        };
      }

      // --- Parse trips.txt (route_id -> shape_id) ---
      const tlines = tripsTxt.trim().split(/\r?\n/);
      const theaders = tlines.shift().split(",");
      const tidx = Object.fromEntries(theaders.map((h,i)=>[h,i]));
      for (const line of tlines) {
        const parts = line.split(",");
        const rid = parts[tidx["route_id"]];
        const sid = parts[tidx["shape_id"]];
        if (!rid || !sid) continue;
        if (!routeToShapes[rid]) routeToShapes[rid] = new Set();
        routeToShapes[rid].add(sid);
      }

      // Initialise empty layer
      map.addSource("routes",{type:"geojson",data:{type:"FeatureCollection",features:[]}});
      map.addLayer({
        id:"route-lines",
        type:"line",
        source:"routes",
        paint:{
          "line-color":"#0077cc",
          "line-width":2,
          "line-opacity":0.6
        }
      });

      // Initialise user location layer
      map.addSource("user-location", { type: "geojson", data: userLocation });
      map.addLayer({
        id:"user-location-circle",
        type:"circle",
        source:"user-location",
        paint:{
          "circle-radius":10,
          "circle-color":"#0066ff",
          "circle-stroke-width":2,
          "circle-stroke-color":"#fff"
        }
      });
    }

    async function fetchFeedAndUpdate() {
      try {
        const res = await fetch(PROXY_FEED_URL, {cache: 'no-store'});
        if (!res.ok) throw new Error('Network response not ok: ' + res.status);
        const buffer = await res.arrayBuffer();
        const uint8 = new Uint8Array(buffer);
        const message = feedMessageType.decode(uint8);
        const object = feedMessageType.toObject(message, { longs: String, enums: String, bytes: String });
        const geojson = feedToGeoJSON(object);
        updateHistory(geojson);
        vehiclesGeoJSON = geojson;
        updateMapSource();
        // Display time with seconds
        const now = new Date();
        lastUpdateEl.textContent = now.toLocaleTimeString();
        countEl.textContent = geojson.features.length;
      } catch (err) {
        console.error(err);
        lastUpdateEl.textContent = 'Error fetching feed';
      }
    }

    function feedToGeoJSON(feedObj) {
      const feats = [];
      if (!feedObj || !feedObj.entity) return { type: 'FeatureCollection', features: [] };
      for (const e of feedObj.entity) {
        if (!e.vehicle) continue;
        const vp = e.vehicle.position;
        if (!vp || vp.latitude == null || vp.longitude == null) continue;
        const props = {
          id: e.id || (e.vehicle.vehicle && e.vehicle.vehicle.id) || null,
          label: (e.vehicle.vehicle && `${e.vehicle.trip.routeId.split("-")[0]}: ${e.vehicle.vehicle.label}`) || null,
          route_id: e.vehicle.trip && e.vehicle.trip.routeId || null,
          trip_id: e.vehicle.trip && e.vehicle.trip.tripId || null,
          bearing: vp.bearing || null,
          speed: vp.speed || null,
          current_stop_sequence: e.vehicle.currentStopSequence || null,
          timestamp: e.vehicle.timestamp || null
        };
        feats.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [vp.longitude, vp.latitude] },
          properties: props
        });
      }
      return { type: 'FeatureCollection', features: feats };
    }

    function updateHistory(currentGeoJSON) {
      const now = Date.now();
      for (const f of currentGeoJSON.features) {
        if (f.properties.timestamp && f.properties.id) {
          const vehicleId = f.properties.id;
          const tsMs = Number(f.properties.timestamp) * 1000;
          
          if (!vehicleHistory[vehicleId]) {
            vehicleHistory[vehicleId] = [];
          }
          
          // Add new position if it's not a duplicate
          const history = vehicleHistory[vehicleId];
          const isDuplicate = history.length > 0 && 
            history[history.length - 1].timestamp === tsMs;
          
          if (!isDuplicate) {
            history.push({
              coords: f.geometry.coordinates,
              timestamp: tsMs,
              speed: f.properties.speed || 0,
              route_id: f.properties.route_id,
              label: f.properties.label
            });
          }
        }
      }
      
      // Clean up old positions and empty vehicles
      for (const vehicleId in vehicleHistory) {
        vehicleHistory[vehicleId] = vehicleHistory[vehicleId].filter(
          pos => now - pos.timestamp <= HISTORY_WINDOW_MS
        );
        if (vehicleHistory[vehicleId].length === 0) {
          delete vehicleHistory[vehicleId];
        }
      }
    }

    function applyFilter(geojson) {
      const filterText = routeFilterEl.value.trim().toLowerCase();
      if (!filterText) return geojson;
      return {
        type: 'FeatureCollection',
        features: geojson.features.filter(f => {
          return (f.properties.route_id && f.properties.route_id.toLowerCase().includes(filterText)) ||
                 (f.properties.label && f.properties.label.toLowerCase().includes(filterText));
        })
      };
    }

    function buildTrailsGeoJSON() {
      const features = [];
      const filterText = routeFilterEl.value.trim().toLowerCase();
      
      for (const vehicleId in vehicleHistory) {
        const history = vehicleHistory[vehicleId];
        if (history.length < 2) continue; // Need at least 2 points for a line
        
        // Apply filter
        if (filterText) {
          const lastPos = history[history.length - 1];
          const matchesFilter = 
            (lastPos.route_id && lastPos.route_id.toLowerCase().includes(filterText)) ||
            (lastPos.label && lastPos.label.toLowerCase().includes(filterText));
          if (!matchesFilter) continue;
        }
        
        // Calculate average speed for the trail
        // First try to use reported speeds if available
        const speeds = history.map(h => h.speed || 0).filter(s => s > 0);
        let avgSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
        
        // If no reported speeds, calculate from position changes
        if (avgSpeed === 0 && history.length >= 2) {
          let totalDistance = 0;
          let totalTime = 0;
          
          for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            const timeDiff = (curr.timestamp - prev.timestamp) / 1000; // seconds
            
            if (timeDiff > 0) {
              const dist = haversineDistance(
                prev.coords[1], prev.coords[0],
                curr.coords[1], curr.coords[0]
              );
              totalDistance += dist;
              totalTime += timeDiff;
            }
          }
          
          if (totalTime > 0) {
            avgSpeed = totalDistance / totalTime; // meters per second
          }
        }
        
        features.push({
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: history.map(h => h.coords)
          },
          properties: {
            vehicle_id: vehicleId,
            speed: avgSpeed
          }
        });
      }
      
      return { type: 'FeatureCollection', features };
    }

    function calculateDistances(vehicleId) {
      const history = vehicleHistory[vehicleId];
      if (!history || history.length < 2) return [];
      
      const now = Date.now();
      const distances = [];
      const intervals = [10, 20, 30, 60, 120, 180, 300, 600]; // seconds
      
      for (const interval of intervals) {
        const targetTime = now - (interval * 1000);
        
        // Find the closest position in history to this time
        let closestPos = null;
        let minDiff = Infinity;
        
        for (const pos of history) {
          const diff = Math.abs(pos.timestamp - targetTime);
          if (diff < minDiff) {
            minDiff = diff;
            closestPos = pos;
          }
        }
        
        // Calculate distance if we found a position
        if (closestPos && minDiff < interval * 500) { // within half the interval
          const currentPos = history[history.length - 1];
          const distance = haversineDistance(
            closestPos.coords[1], closestPos.coords[0],
            currentPos.coords[1], currentPos.coords[0]
          );
          
          if (distance > 0) {
            const actualTimeDiff = (currentPos.timestamp - closestPos.timestamp) / 1000; // seconds
            const speedMps = actualTimeDiff > 0 ? distance / actualTimeDiff : 0; // m/s
            const speedKmh = Math.round(speedMps * 3.6); // convert to km/h
            distances.push({ 
              interval, 
              distance: Math.round(distance),
              speedKmh 
            });
          }
        }
      }
      
      return distances;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function formatInterval(seconds) {
      if (seconds < 60) return `${seconds}s`;
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      if (secs === 0) return `${minutes}m`;
      return `${minutes}m ${secs}s`;
    }

    function updateMapSource() {
      const filteredVehicles = applyFilter(vehiclesGeoJSON);
      const trailsGeoJSON = buildTrailsGeoJSON();

      // --- Filter shapes based on filter text ---
      const filterText = routeFilterEl.value.trim().toLowerCase();
      let routeIds = new Set();
      if (filterText) {
        for (const rid in routeToShapes) {
          if (rid.toLowerCase().includes(filterText)) routeIds.add(rid);
        }
      } else {
        // include routeIds seen in current vehicles (avoid showing entire network)
        filteredVehicles.features.forEach(f => {
          if (f.properties.route_id) routeIds.add(f.properties.route_id);
        });
      }
      const shapeFeatures = [];
      for (const rid of routeIds) {
        const sids = routeToShapes[rid];
        if (!sids) continue;
        for (const sid of sids) {
          if (allShapes[sid]) shapeFeatures.push(allShapes[sid]);
        }
      }

      if (map.getSource('vehicles')) {
        map.getSource('vehicles').setData(filteredVehicles);
        map.getSource('vehicle-trails').setData(trailsGeoJSON);
        map.getSource('routes').setData({type:"FeatureCollection",features:shapeFeatures});
      } else {
        map.addSource('vehicles', { type: 'geojson', data: filteredVehicles });
        map.addLayer({
          id: 'vehicle-circles',
          type: 'circle',
          source: 'vehicles',
          paint: { 'circle-radius': 6, 'circle-stroke-width': 1, 'circle-stroke-color': '#fff' }
        });
        map.addLayer({
          id: 'vehicle-labels',
          type: 'symbol',
          source: 'vehicles',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ['get', 'route_id'], ''],
            'text-size': 12,
            'text-offset': [0, 1.3]
          }
        });
        map.on('click', 'vehicle-circles', (e) => {
          const props = e.features[0].properties;
          const vehicleId = props.id;
          
          // Create improved popup HTML
          let html = `<div style="font-family: inherit; min-width: 200px; max-width: 280px; padding: 4px;">`;
          html += `<div style="font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #0077cc; word-wrap: break-word;">${props.label || props.route_id || 'Vehicle'}</div>`;
          
          // Vehicle details
          html += `<div style="font-size: 13px; line-height: 1.6; color: #555;">`;
          html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Trip ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.trip_id || '‚Äî'}</strong></div>`;
          html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Vehicle ID:</span> <strong style="word-wrap: break-word; word-break: break-all;">${props.id || '‚Äî'}</strong></div>`;
          
          // Last seen time
          if (props.timestamp) {
            const lastSeenTime = new Date(Number(props.timestamp) * 1000);
            const timeStr = lastSeenTime.toLocaleTimeString();
            html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Last seen:</span> <strong>${timeStr}</strong></div>`;
          }
          
          // Add current speed if available
          if (vehicleId && vehicleHistory[vehicleId] && vehicleHistory[vehicleId].length >= 2) {
            const history = vehicleHistory[vehicleId];
            const lastPos = history[history.length - 1];
            const prevPos = history[history.length - 2];
            const timeDiff = (lastPos.timestamp - prevPos.timestamp) / 1000;
            
            if (timeDiff > 0) {
              const distance = haversineDistance(
                prevPos.coords[1], prevPos.coords[0],
                lastPos.coords[1], lastPos.coords[0]
              );
              const speedMps = distance / timeDiff;
              const speedKmh = Math.round(speedMps * 3.6);
              html += `<div style="margin-bottom: 4px;"><span style="color: #888;">Current speed:</span> <strong style="color: #0077cc;">${speedKmh} km/h</strong></div>`;
            }
          }
          html += `</div>`;
          
          // Add distance history if available
          if (vehicleId && vehicleHistory[vehicleId]) {
            const distances = calculateDistances(vehicleId);
            if (distances.length > 0) {
              html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e8e8e8;">`;
              html += `<div style="font-size: 13px; font-weight: 600; color: #1a1a1a; margin-bottom: 6px;">Distance traveled:</div>`;
              html += '<div style="font-size: 12px; color: #666; line-height: 1.8;">';
              for (const d of distances) {
                const avgSpeed = d.speedKmh;
                const speedColor = avgSpeed > 40 ? '#4CAF50' : avgSpeed > 20 ? '#FFC107' : '#888';
                html += `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;">`;
                html += `<span>${formatInterval(d.interval)}:</span>`;
                html += `<span><strong>${d.distance}m</strong> <span style="color: ${speedColor};">(${d.speedKmh} km/h)</span></span>`;
                html += `</div>`;
              }
              html += '</div></div>';
            }
          }
          
          html += '</div>';
          new maplibregl.Popup({
            maxWidth: '300px',
            className: 'custom-popup'
          }).setLngLat(e.lngLat).setHTML(html).addTo(map);
        });
        map.on('mouseenter', 'vehicle-circles', () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', 'vehicle-circles', () => map.getCanvas().style.cursor = '');

        map.addSource('vehicle-trails', { type: 'geojson', data: trailsGeoJSON });
        map.addLayer({
          id: 'vehicle-trails-lines',
          type: 'line',
          source: 'vehicle-trails',
          paint: {
            'line-width': 2,
            'line-color': [
              'interpolate',
              ['linear'],
              ['get', 'speed'],
              0, '#888888',      // Stationary: grey
              5, '#4CAF50',      // Slow: green (5 m/s ‚âà 18 km/h)
              10, '#FFC107',     // Medium: amber (10 m/s ‚âà 36 km/h)
              15, '#FF9800',     // Fast: orange (15 m/s ‚âà 54 km/h)
              20, '#F44336'      // Very fast: red (20 m/s ‚âà 72 km/h)
            ],
            'line-opacity': 0.6
          }
        }, 'vehicle-circles'); // Add trails below vehicle circles
        map.getSource("routes").setData({type:"FeatureCollection",features:shapeFeatures});
      }
    }

    refreshBtn.addEventListener('click', () => fetchFeedAndUpdate());
    routeFilterEl.addEventListener('input', () => updateMapSource());
    autoRefreshBtn.addEventListener('click', () => { 
      autoRefreshBtn.classList.toggle('active');
      if (autoRefreshBtn.classList.contains('active')) {
        startAutoRefresh();
      } else {
        stopAutoRefresh();
      }
    });
    locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) return alert('Geolocation not available');
      navigator.geolocation.getCurrentPosition(pos => {
        const coords = [pos.coords.longitude, pos.coords.latitude];
        userLocation.features = [{
          type: 'Feature',
          geometry: { type: 'Point', coordinates: coords }
        }];
        map.getSource('user-location').setData(userLocation);
        map.flyTo({ center: coords, zoom: 14 });
      }, e => alert('Unable to get location: ' + e.message));
    });

    function startAutoRefresh() {
      stopAutoRefresh();
      autoTimer = setInterval(fetchFeedAndUpdate, REFRESH_INTERVAL_MS);
    }
    function stopAutoRefresh() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }

    (async function(){
      try {
        await loadProto();
        map.on('load', async () => {
          await loadGTFS();
          fetchFeedAndUpdate();
          startAutoRefresh();
        });
      } catch (err) {
        console.error('Startup error', err);
        alert('Failed to initialise: ' + err.message);
      }
    })();
  </script>
</body>
</html>
